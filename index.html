<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Isola della Sopravvivenza - Online</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Stili CSS (invariati) */
        @keyframes pulse { 0%, 100% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.7); } 50% { box-shadow: 0 0 0 10px rgba(251, 191, 36, 0); } }
        @keyframes fade-out { from { opacity: 1; transform: scale(1); } to { opacity: 0; transform: scale(0.9); } }
        @keyframes winner-reveal { 0% { transform: scale(0.5); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        @keyframes dice-roll-suspense { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }

        body { font-family: 'Inter', sans-serif; background-image: url('https://www.transparenttextures.com/patterns/wood-pattern.png'); background-color: #f0e6d2; overflow-x: hidden; }
        .modal { display: none; position: fixed; z-index: 50; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7); backdrop-filter: blur(5px); }
        .modal-content { background-color: #fefefe; margin: 5% auto; padding: 20px; border: 1px solid #888; width: 90%; max-width: 600px; border-radius: 10px; }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close:hover, .close:focus { color: black; text-decoration: none; }
        .character-card { position: relative; transition: all 0.3s ease; cursor: pointer; border: 3px solid transparent; overflow: hidden; }
        .character-card.selected { border-color: #10B981; transform: scale(1.05); box-shadow: 0 0 15px rgba(16, 185, 129, 0.8); }
        .character-card.player-controlled { border-width: 4px; border-color: #3B82F6; box-shadow: 0 0 10px rgba(59, 130, 246, 0.7); }
        .character-card.locked { filter: grayscale(80%) brightness(0.7); cursor: not-allowed; }
        .character-card.disabled { cursor: not-allowed; }
        .character-card.immune-aura { animation: pulse 2s infinite; border-color: #FBBF24; }
        .character-card.eliminated { filter: grayscale(100%); background-color: #7f1d1d; transform: scale(0.95); }
        .character-card.fading-out { animation: fade-out 0.5s forwards; }
        .team-container { background-color: rgba(255, 255, 255, 0.7); backdrop-filter: blur(5px); }
        .winner-card { animation: winner-reveal 1s ease-out forwards; }
        .dice-suspense { animation: dice-roll-suspense 0.1s infinite; }
    </style>
</head>
<body class="bg-gray-100">

    <!-- Schermata Menu Principale -->
    <div id="main-menu" class="min-h-screen flex items-center justify-center">
        <div class="w-full max-w-md p-8 space-y-6 bg-white rounded-xl shadow-lg">
            <h1 class="text-3xl font-bold text-center text-gray-800">Isola della Sopravvivenza</h1>
            <div><label for="nickname" class="block text-sm font-medium text-gray-700">Nickname</label><input type="text" id="nickname" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm" value="Giocatore"></div>
            <div><label class="block text-sm font-medium text-gray-700">Immagine del Giocatore</label><div class="mt-1 flex items-center space-x-4"><img id="player-image-preview" src="https://placehold.co/80x80/000000/FFFFFF?text=?" class="w-20 h-20 rounded-full object-cover bg-gray-300"><div class="flex flex-col space-y-2"><label for="image-upload" class="cursor-pointer px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 text-sm text-center">Carica File<input type="file" id="image-upload" class="hidden" accept="image/png, image/jpeg"></label><button id="image-url-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 text-sm">Usa URL</button></div></div></div>
            <div class="space-y-4 border-t pt-4">
                <button id="open-mode-selection-btn" class="w-full px-4 py-3 font-semibold text-white bg-green-500 rounded-md hover:bg-green-600">Crea Stanza</button>
                <div class="flex items-center space-x-2">
                    <input type="text" id="room-id-input" placeholder="ID Stanza" class="block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm">
                    <button id="join-room-btn" class="px-4 py-2 font-semibold text-white bg-blue-500 rounded-md hover:bg-blue-600 whitespace-nowrap">Entra</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Schermata Selezione Personaggio (Lobby) -->
    <div id="character-selection-screen" class="hidden w-full h-screen"><div class="flex h-full"><div class="flex-grow p-4 overflow-auto"><h2 id="char-select-title" class="text-3xl font-bold text-center mb-2 text-gray-800">Scegli il tuo Personaggio</h2><p id="char-select-subtitle" class="text-center text-gray-600 mb-6">Scegli un personaggio da controllare nel gioco.</p><div id="char-select-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 xl:grid-cols-8 gap-4"></div></div><div class="w-1/4 min-w-[300px] bg-white bg-opacity-80 rounded-lg shadow-lg p-4 flex flex-col"><div class="mb-4"><label class="font-bold">ID Stanza (condividi con gli amici):</label><div class="flex items-center"><input type="text" id="room-id-display" readonly class="w-full bg-gray-200 px-2 py-1 rounded"><button id="copy-room-id-btn" class="ml-2 px-2 py-1 bg-gray-300 rounded">Copia</button></div></div><h3 class="text-2xl font-bold mb-4 text-gray-800">Giocatori nella Lobby</h3><div id="player-char-list" class="flex-grow space-y-3 overflow-y-auto"></div><div class="mt-4"><button id="start-game-btn" class="w-full px-4 py-3 font-semibold text-white bg-red-600 rounded-md hover:bg-red-700 disabled:bg-gray-400 disabled:cursor-not-allowed">Inizia Partita (Solo Host)</button></div></div></div></div>

    <!-- Schermata di Gioco Principale -->
    <div id="main-game-screen" class="hidden w-full h-screen"><div class="flex h-full">
        <div id="relationships-hud" class="w-1/4 min-w-[300px] bg-white bg-opacity-80 rounded-lg shadow-lg p-4 flex-col hidden mr-4"><h3 class="text-2xl font-bold mb-4 text-gray-800">Le tue Relazioni</h3><div class="flex-grow space-y-3 overflow-y-auto"><div id="friends-list"></div><div id="allies-list"></div><div id="enemies-list"></div></div></div>
        <div class="flex-grow p-4 overflow-auto">
            <h2 id="episode-title" class="text-4xl font-bold text-center mb-2 text-gray-800"></h2>
            <p id="game-status-text" class="text-center text-xl text-gray-600 mb-8"></p>
            <div id="teams-container" class="flex flex-wrap justify-center gap-6"></div>
            <div id="elimination-ranking-container" class="mt-8">
                <h4 class="text-2xl font-bold mb-4 text-center text-gray-900 drop-shadow-md">Classifica Eliminati</h4>
                <div id="elimination-ranking-list" class="flex flex-wrap justify-center gap-4 p-4 bg-black bg-opacity-20 rounded-lg">
                </div>
            </div>
        </div>
        <div id="right-panel" class="w-1/4 min-w-[350px] bg-white bg-opacity-80 rounded-lg shadow-lg p-4 flex flex-col">
            <h3 class="text-2xl font-bold mb-4 text-gray-800">Stato Giocatori</h3>
            <div id="player-status-container" class="space-y-3"></div>
            <div class="mt-4 border-t pt-4 flex-grow flex flex-col min-h-0">
                <h4 class="text-xl font-bold mb-2 text-gray-800">Log Interazioni</h4>
                <div id="interaction-log" class="flex-grow space-y-2 overflow-y-auto text-xs bg-gray-100 p-2 rounded-lg" style="max-height: 150px;">
                    <p class="text-gray-500">Nessuna interazione ancora.</p>
                </div>
            </div>
            <div id="host-panel" class="mt-4 border-t pt-4">
                <h4 class="font-bold text-center text-lg">Pannello Azioni</h4>
                <p id="host-instructions" class="text-center text-sm text-gray-600 my-2"></p>
                <button id="next-step-btn" class="w-full px-4 py-3 font-semibold text-white bg-blue-600 rounded-md hover:bg-blue-700">Procedi</button>
            </div>
        </div>
    </div></div>

    <!-- Modali (invariati) -->
    <div id="mode-selection-modal" class="modal"><div class="modal-content text-center"><h2 class="text-2xl font-bold mb-6">Scegli la Modalità di Gioco</h2><div class="flex justify-around"><button id="select-judge-mode" class="px-8 py-4 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600">Modalità Giudice</button><button id="select-contestant-mode" class="px-8 py-4 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-600">Modalità Concorrente</button></div></div></div>
    <div id="create-room-modal" class="modal"><div class="modal-content"><span class="close">&times;</span><h2 class="text-xl font-semibold mb-4">Configurazione Stanza</h2><div class="space-y-4"><div><label for="num-contestants" class="block text-sm font-medium">Numero Concorrenti (12-40)</label><input type="number" id="num-contestants" min="12" max="40" value="12" class="w-full mt-1 border-gray-300 rounded-md"></div><div><label for="num-teams" class="block text-sm font-medium">Numero Team (2-6)</label><input type="number" id="num-teams" min="2" max="6" value="2" class="w-full mt-1 border-gray-300 rounded-md"></div><div id="team-names-container"></div><div><label for="merge-episode" class="block text-sm font-medium">Episodio del Merge</label><input type="number" id="merge-episode" min="1" value="7" class="w-full mt-1 border-gray-300 rounded-md"></div><div id="comeback-config-container"></div><button id="confirm-create-room" class="w-full px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600">Conferma e Crea Stanza</button></div></div></div>
    <div id="action-phase-modal" class="modal"><div class="modal-content text-center"><h2 class="text-2xl font-bold mb-6">Fase Azione</h2><p class="mb-4">Scegli la tua mossa per questo episodio.</p><div class="flex justify-around"><button id="action-interact" class="px-6 py-3 bg-blue-500 text-white rounded-md hover:bg-blue-600">Interagisci</button><button id="action-sabotage" class="px-6 py-3 bg-red-500 text-white rounded-md hover:bg-red-600">Sabota</button><button id="action-nothing" class="px-6 py-3 bg-gray-500 text-white rounded-md hover:bg-gray-600">Non fare nulla</button></div></div></div>
    <div id="interaction-modal" class="modal"><div class="modal-content"><h2 class="text-2xl font-bold text-center mb-4">Interagisci con...</h2><div id="interaction-candidates-container" class="grid grid-cols-2 md:grid-cols-4 gap-4"></div></div></div>
    <div id="voting-modal" class="modal"><div class="modal-content"><h2 class="text-2xl font-bold text-center mb-4">Vota per l'eliminazione</h2><p class="text-center mb-4">Clicca sul concorrente che vuoi eliminare.</p><div id="voting-candidates-container" class="grid grid-cols-2 md:grid-cols-4 gap-4"></div></div></div>
    <div id="elimination-ceremony-modal" class="modal bg-black bg-opacity-90"><div class="w-full h-full flex flex-col items-center justify-center text-white p-8 relative"><h2 id="ceremony-status" class="text-5xl font-bold text-yellow-300 drop-shadow-lg mb-4">Cerimonia di Eliminazione</h2><p id="ceremony-details" class="text-2xl mb-8"></p><div id="ceremony-candidates-container" class="flex flex-wrap justify-center gap-6 mb-6"></div><div id="ceremony-votes-readout" class="w-full max-w-lg text-left"></div><button id="skip-ceremony-btn" class="absolute bottom-5 right-5 px-4 py-2 bg-yellow-500 text-black rounded-md hover:bg-yellow-600 font-bold">Salta Cerimonia</button></div></div>
    <div id="finale-voting-modal" class="modal"><div class="modal-content"><h2 class="text-2xl font-bold text-center mb-4">Voto Finale</h2><p class="text-center mb-4">La giuria sta votando... Chi merita di vincere?</p><div id="finale-candidates-container" class="flex justify-center gap-6"></div></div></div>
    <div id="winner-modal" class="modal bg-yellow-300 bg-opacity-80"><div class="w-full h-full flex flex-col items-center justify-center text-gray-900 p-8 text-center"><h2 class="text-6xl font-bold drop-shadow-lg mb-4">IL VINCITORE È...</h2><div id="winner-card-container"></div><button id="show-ranking-btn" class="mt-8 px-6 py-3 bg-blue-600 text-white font-bold rounded-lg shadow-lg hover:bg-blue-700">Mostra Classifica Finale</button></div></div>
    <div id="ranking-modal" class="modal"><div class="modal-content"><h2 class="text-2xl font-bold text-center mb-4">Classifica Finale</h2><ol id="ranking-list" class="list-decimal list-inside space-y-2"></ol></div></div>
    <div id="image-url-modal" class="modal"><div class="modal-content"><span class="close">&times;</span><h2 class="text-xl font-semibold mb-4">Inserisci URL Immagine</h2><input type="text" id="image-url-input" class="w-full px-3 py-2 border border-gray-300 rounded-md" placeholder="https://..."><button id="submit-image-url" class="mt-4 px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600">Conferma</button></div></div>
    <div id="custom-alert-modal" class="modal"><div class="modal-content text-center"><h2 id="custom-alert-title" class="text-xl font-bold mb-4"></h2><p id="custom-alert-message" class="mb-6"></p><button id="custom-alert-close" class="px-6 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600">OK</button></div></div>
    <div id="tie-breaker-modal" class="modal bg-gray-900 bg-opacity-90"><div class="modal-content bg-gray-800 text-white border-yellow-400 border-2"><h2 class="text-3xl font-bold text-center text-yellow-300 drop-shadow-lg mb-4">SPAREGGIO!</h2><p id="tie-breaker-status" class="text-center mb-6">I seguenti concorrenti hanno pareggiato. Devono sfidarsi al lancio del dado per salvarsi!</p><div id="tie-breaker-players" class="flex justify-center items-start gap-6 mb-6"></div><div id="tie-breaker-controls" class="text-center mt-4"><button id="force-roll-btn" class="px-4 py-2 bg-yellow-500 text-black text-sm rounded-md hover:bg-yellow-600">Forza Lancio CPU (Host)</button></div></div></div>

    <script type="module">
        // --- IMPORTAZIONI FIREBASE ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, addDoc, serverTimestamp, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- CONFIGURAZIONE FIREBASE ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        let currentUserId = null;
        let currentRoomId = null;
        let unsubscribeFromRoom = null; 

        // --- STATO LOCALE E DATI ---
        let localPlayerInfo = { nickname: "Giocatore", img: "https://placehold.co/80x80/000000/FFFFFF?text=?" };
        let gameState = {}; // Copia locale dello stato su Firebase
        const castData = [ { name: 'Gumball', img: 'https://i.pinimg.com/736x/af/61/0f/af610f55e819f4bd3f37e5001a2b19ee.jpg' }, { name: 'Darwin', img: 'https://i.pinimg.com/736x/44/ad/5f/44ad5f25f6dae6e19757b15346684583.jpg' }, { name: 'Anais', img: 'https://i.pinimg.com/1200x/26/f8/72/26f8725b4a109e67d385f7f049beb64d.jpg' }, { name: 'Nicole', img: 'https://i.pinimg.com/736x/4e/ac/70/4eac705ff7feba9202c200de511c8583.jpg' }, { name: 'Richard', img: 'https://i.pinimg.com/736x/d5/24/9f/d5249fcdd9dd6a3665bcdccd94a47f6f.jpg' }, { name: 'Perla', img: 'https://i.pinimg.com/1200x/c4/e4/68/c4e468b58c65cac7ab819e34302676a1.jpg' }, { name: 'Steven', img: 'https://i.pinimg.com/736x/1c/3c/83/1c3c83c96596d34adda0c0d9f23d34e8.jpg' }, { name: 'Garnet', img: 'https://i.pinimg.com/736x/47/9e/df/479edf90183bf09eec11ecf34325e0bb.jpg' }, { name: 'Ametista', img: 'https://i.pinimg.com/736x/b1/07/fe/b107fe61d0f329ed7447da0198c8da24.jpg' }, { name: 'Lapis', img: 'https://i.pinimg.com/736x/94/58/a8/9458a8a235f2cbc6a4b5b19758ace36a.jpg' }, { name: 'Stewie', img: 'https://i.pinimg.com/1200x/b9/96/fe/b996fedab3debb67906da29e51525ab5.jpg' }, { name: 'Brian', img: 'https://i.pinimg.com/736x/4b/0d/7c/4b0d7cd213626b371b1493c67654c902.jpg' }, { name: 'Peter', img: 'https://i.pinimg.com/736x/9e-40/74/9e-40-74bbe7890cd245b51b9ff5c0e33c.jpg' }, { name: 'Lois', img: 'https://i.pinimg.com/1200x/65/e2/03/65e203e2ea7ba98ab49dfeeb9adebcaa.jpg' }, { name: 'Lisa', img: 'https://i.pinimg.com/736x/e5/2d/fe/e52dfee5a58f5dad19f9e0592c63a7cd.jpg' }, { name: 'Bart', img: 'https://i.pinimg.com/1200x/cf/dc/86/cfdc8641fb98a49c0e731a8e6c002b02.jpg' }, { name: 'Homer', img: 'https://i.pinimg.com/736x/25/71/8e/25718eb490b2eb301a2854c5dc74e75b.jpg' }, { name: 'Ned', img: 'https://i.pinimg.com/736x/9e-30/66/9e-30-66e2c2dff381cb878bbc3d3ba23a.jpg' }, { name: 'Stan', img: 'https://i.pinimg.com/736x/cc/48/c0/cc48c09c661d4f9af432a37c6b908e41.jpg' }, { name: 'Francine', img: 'https://i.pinimg.com/736x/18/c1/d2/18c1d2489a64b1b4f9cc78318e62da94.jpg' }, { name: 'Hayley', img: 'https://i.pinimg.com/736x/ff/0a/68/ff0a68de85d1bd98e29be7c05860b437.jpg' }, { name: 'Steve', img: 'https://i.pinimg.com/1200x/ad/b3/46/adb3465ea7efcf62537e95496d56a443.jpg' }, { name: 'Roger', img: 'https://i.pinimg.com/736x/32/27/79/322779874c754bcf1c1cc9fdd11252f5.jpg' }, { name: 'Leela', img: 'https://i.pinimg.com/736x/24/d4/80/24d4800deb67dcc14af56453c8c8c902.jpg' }, { name: 'Fry', img: 'https://i.pinimg.com/1200x/9c/df/cb/9cdfcb9b2a3f9653c7614c0ceb5798b5.jpg' }, { name: 'Bender', img: 'https://i.pinimg.com/736x/17/e2/65/17e2654def74fcc7137d202fb48f7c9a.jpg' }, { name: 'Robot Boy', img: 'https://i.pinimg.com/736x/77/78/2a/77782abe9ee9e431be635c6395322a0f.jpg' }, { name: 'Robot Girl', img: 'https://i.pinimg.com/736x/43/f9/7b/43f97b098e608a3e61b65aabf935bf5f.jpg' }, { name: 'Yang', img: 'https://i.pinimg.com/736x/ea/8f/2c/ea8f2c18bf548e4be17ab499aa98acb3.jpg' }, { name: 'Ying', img: 'https://i.pinimg.com/1200x/13/b4/ff/13b4ff2998c7f763004788fd67468e61.jpg' }, { name: 'Po', img: 'https://i.pinimg.com/1200x/e7/d4/62/e7d4628748d9b65e57e552ccf39fa935.jpg' }, { name: 'Tigre', img: 'https://i.pinimg.com/736x/e8/a6/52/e8a652c389c31e0be3232db065c3ce2f.jpg' }, { name: 'Shifu', img: 'https://i.pinimg.com/1200x/32/74/37/3274379162f8c714fa75a2391e56bed8.jpg' }, { name: 'Pucca', img: 'https://i.pinimg.com/736x/4f/c7/16/4fc716c74fd3c36cdf9c774546a94f9d.jpg' }, { name: 'Garu', img: 'https://i.pinimg.com/736x/ee/d6/41/eed6413f9bde5936c76cd8a0a96fcc3a.jpg' }, { name: 'Doraemon', img: 'https://i.pinimg.com/736x/ef/43/fc/ef43fc1923e2904d1007b3b8b7a2e509.jpg' }, { name: 'Nobita', img: 'https://i.pinimg.com/1200x/d4/ee/64/d4ee644406a064665a33d74980744e6f.jpg' }, { name: 'Phineas', img: 'https://i.pinimg.com/736x/01/f8/d9/01f8d9e5651859eab697441a4e7d69c7.jpg' }, { name: 'Ferb', img: 'https://i.pinimg.com/1200x/68/04/c6/6804c62c210eef6288ca1d555db326ef.jpg' }, { name: 'Isabella', img: 'https://i.pinimg.com/1200x/8f/b6/53/8fb6531754417925d60f7ba9276d824d.jpg' }, { name: 'Candace', img: 'https://i.pinimg.com/736x/e3/9d/95/e39d9504c7131e87c662b1f0537c3d7b.jpg' }, { name: 'Perry', img: 'https://i.pinimg.com/736x/6e/a4/33/6ea433e585e73b90d08f32e37b8047a7.jpg' }, { name: 'Stacy', img: 'https://i.pinimg.com/736x/49/5f/a2/495fa207ac08afdb0edd09019e4a06a4.jpg' }, { name: 'Spongebob', img: 'https://i.pinimg.com/736x/cf/8d/06/cf8d06adf1b9d91bacca860aed203dfd.jpg' }, { name: 'Patrick', img: 'https://i.pinimg.com/736x/0c/d7/cf/0cd7cfd63876a6579e68e53e10b4214e.jpg' }, { name: 'Squiddi', img: 'https://i.pinimg.com/736x/50/6d/1c/506d1c34be865276fc5914be49040b54.jpg' }, { name: 'Gary', img: 'https://i.pinimg.com/736x/87/a1/dc/87a1dcba8692affe1b31245d7fcc185a.jpg' }, { name: 'Robin GO', img: 'https://i.pinimg.com/736x/92/b6/50/92b650adbe57c5cec55a3ef46b65e933.jpg' }, { name: 'Robin TT', img: 'https://i.pinimg.com/1200x/3d/6c/68/3d6c6831fbe71721985a26e79f246049.jpg' }, { name: 'Stellarubia GO', img: 'https://i.pinimg.com/736x/5d/fc/47/5dfc47f4c755927482bd87b140d73850.jpg' }, { name: 'Stellarubia TT', img: 'https://i.pinimg.com/1200x/71/8e/9c/718e9ce6ee44358f4c99c2324c647101.jpg' }, { name: 'Corvina GO', img: 'https://i.pinimg.com/736x/a9/17/ed/a917ed4a9d6aadbd08868726c1069990.jpg' }, { name: 'Corvina TT', img: 'https://i.pinimg.com/736x/f4/d1/82/f4d182fd25c3ba3f07ae24b6518aa88b.jpg' }, { name: 'Wasabi', img: 'https://m.media-amazon.com/images/M/MV5BMjFlYzMwNDYtNDRiNS00YWRiLTg3YTAtNWFlNDk1MTZlYTk3XkEyXkFqcGc@._V1_.jpg' }, { name: 'Rekkit', img: 'https://simkl.in/episodes/16/162611351d718a4256_c.jpg' }, { name: 'Cosmo', img: 'https://i.pinimg.com/736x/47/22/99/472299b4c669c052c662df1730403d83.jpg' }, { name: 'Wanda', img: 'https://i.pinimg.com/736x/76/63/2c/76632cdd5765893ba8fbe9de12485dff.jpg' }, { name: 'Vicky', img: 'https://i.pinimg.com/736x/94/8c/a2/948ca2bf95d2536533c916cdce8b9ebc.jpg' }, { name: 'Papà di Timmy', img: 'https://i.pinimg.com/1200x/fe/a5/f3/fea5f385a3fb67dabe02838c2f3720dc.jpg' }, { name: 'Timmy', img: 'https://i.pinimg.com/736x/1d/54/89/1d548928bac7ea94fcad567cf74721ab.jpg' }, { name: 'Finn', img: 'https://i.pinimg.com/736x/8a/f3/a3/8af3a35a8e4397b9c5d81e0f4d42a2b0.jpg' }, { name: 'Jake', img: 'https://i.pinimg.com/736x/00/07/e5/0007e54a9a0d180850ed97718df1e432.jpg' }, { name: 'Gunter', img: 'https://i.pinimg.com/736x/26/96/ed/2696eda8f5c9babb308d1f123724b7c8.jpg' }, { name: 'Gommarosa', img: 'https://i.pinimg.com/736x/27/3e/df/273edf0076e41b90096717b89e04c1aa.jpg' }, { name: 'Marceline', img: 'https://i.pinimg.com/736x/bb/93/5e/bb935e39f2d66248b6e4178227bdb233.jpg' }, { name: 'Peach', img: 'https://i.pinimg.com/736x/e2/0b/46/e20b46677a4ac93d8de0f1877c264f4e.jpg' }, { name: 'Daisy', img: 'https://i.pinimg.com/1200x/fd/1d/4f/fd1d4f2285878621d08f7edacace0219.jpg' }, { name: 'Rosalinda', img: 'https://i.pinimg.com/736x/09/14/f0/0914f029e712e92de9d4f0081a5da032.jpg' }, { name: 'Wario', img: 'https://i.pinimg.com/736x/07/72/16/07721681614a459938a7f85ec450f957.jpg' }, { name: 'Yoshi', img: 'https://i.pinimg.com/1200x/08/ad/ab/08adaba4772c6d9de6b01d4fb6782d66.jpg' }, { name: 'Toadette', img: 'https://i.pinimg.com/1200x/dc/a5/b3/dca5b320572ae5daeb6fc46950c99101.jpg' }, { name: 'Johnny', img: 'https://i.pinimg.com/1200x/fc/a8/42/fca8428053cad044c13c16a941093275.jpg' }, { name: 'Billy', img: 'https://i.pinimg.com/736x/b6/55/a2/b655a2923fd04d20f9cf2520e8724536.jpg' }, { name: 'Mandy', img: 'https://i.pinimg.com/736x/9f/fc/09/9ffc0904acd73935296ce3dce83b66d2.jpg' }, { name: 'Tenebra', img: 'https://i.pinimg.com/736x/98/53/1e/98531e1d92e69384bd34411a21ec0256.jpg' }, { name: 'Carlos', img: 'https://i.pinimg.com/736x/04/bb/63/04bb630cd30a6c91f7792e77cc989394.jpg' }, { name: 'Ada Wong', img: 'https://i.pinimg.com/736x/19/ca/67/19ca678bedd73e74380204b75852e476.jpg' }, { name: 'Aang', img: 'https://i.pinimg.com/736x/21/c6/02/21c60273e7409b871140d5cee2cace5b.jpg' }, { name: 'Katara', img: 'https://i.pinimg.com/736x/f1/56/17/f156175f5f7790ef5e4632ce8086ba4a.jpg' }, { name: 'Zuko', img: 'https://i.pinimg.com/736x/86/b6/f3/86b6f3d6f859ea16d4e0d3d55e8bf3e4.jpg' }, { name: 'Toph', img: 'https://i.pinimg.com/736x/14/8a/3e/148a3efd1a09e4a858a389754afc5880.jpg' }, { name: 'Pikachu', img: 'https://i.pinimg.com/736x/ad/65/b6/ad65b669746561313925ffff392518bc.jpg' }, { name: 'Eevee', img: 'https://i.pinimg.com/1200x/09/52/82/095282d3ad6396e10730dabddceb3da0.jpg' }, { name: 'Ezio', img: 'https://i.pinimg.com/736x/94/3f/42/943f4260b7afd432b7f903772a914ed8.jpg' }, { name: 'Kirby', img: 'https://i.pinimg.com/736x/ba/e6/63/bae6637b3efecfd002f0c1f9605e53be.jpg' }, { name: 'Sonic', img: 'https://i.pinimg.com/736x/80/60/35/8060350ecfa5e867a48bab8f4744deb6.jpg' }, { name: 'Amy', img: 'https://i.pinimg.com/736x/b9/22/82/b9228241a5657f48ef8ea867ca4a4953.jpg' }, { name: 'Blaze', img: 'https://i.pinimg.com/736x/b8/89/61/b889619ef87861b12d6171172cf851a1.jpg' }, { name: 'Lillipup', img: 'https://i.pinimg.com/736x/e8/e2/47/e8e247cafe563d725c799f05a803fa1c.jpg' }, { name: 'Gwen', img: 'https://i.pinimg.com/736x/6d/86/50/6d86501af8e0b9e30b032cbfaad825d6.jpg' }, { name: 'Duncan', img: 'https://i.pinimg.com/1200x/a1/56/b1/a156b1d64b2e5309a8999be12c9a7247.jpg' }, { name: 'Courtney', img: 'https://i.pinimg.com/1200x/0a/c5/52/0ac5521dddf64ab0b5d08e6e36a2c10b.jpg' }, { name: 'Heather', img: 'https://i.pinimg.com/1200x/ef/9d/24/ef9d242224e10a517f925d68ee5833be.jpg' }, { name: 'Lindsay', img: 'https://i.pinimg.com/736x/0f/28/70/0f2870a28e938e0b00a489583f1659d3.jpg' }, { name: 'Alejandro', img: 'https://i.pinimg.com/1200x/e7/86/07/e78607796652e6e6f4b885f077837973.jpg' }, { name: 'Superboy', img: 'https://i.pinimg.com/1200x/34/20/a3/3420a34c3f0a287a8c06d435fcb577b7.jpg' }, { name: 'Ben 10', img: 'https://i.pinimg.com/736x/57/fc/52/57fc521fb6e3078cc118b980769aba8b.jpg' }, { name: 'Kevin', img: 'https://i.pinimg.com/736x/64/fc/a7/64fca772a45a4a332ccf98085f5417be.jpg' }, { name: 'Goku', img: 'https://i.pinimg.com/736x/38/47/f4/3847f4e67f63bc4329e2115b2669adc4.jpg' }, { name: 'Giyu', img: 'https://i.pinimg.com/1200x/46/ba/9b/46ba9b379e5550f14ab4aaa5a38fd80d.jpg' }, { name: 'Shinobu', img: 'https://i.pinimg.com/736x/0b/1d/01/0b1d01c03c7e5a69a92cae9696a528a6.jpg' }, { name: 'Tanjiro', img: 'https://i.pinimg.com/736x/b6/a0/64/b6a064006e8965bdd40128bbc8618a54.jpg' }, { name: 'Zenitsu', img: 'https://i.pinimg.com/736x/7c/67/f6/7c67f662bc3cfb7a82482a5d6e7e2837.jpg' }, { name: 'Hinosuke', img: 'https://i.pinimg.com/736x/21/98/f4/2198f46f5b1853035154873dd1a57950.jpg' }, { name: 'Rias', img: 'https://i.pinimg.com/736x/8d/e5/55/8de555c9e80992d31f7e4edebf190c1a.jpg' }, ];

        // --- DOM Element Variables ---
        let mainMenu, mainGameScreen, characterSelectionScreen, modeSelectionModal, createRoomModal,
            actionPhaseModal, interactionModal, votingModal, ceremonyModal, nextStepBtn, skipCeremonyBtn,
            episodeTitle, gameStatusText, hostInstructions, customAlertModal, tieBreakerModal;

        // --- FUNZIONI DI GESTIONE STANZA ---

        async function createRoom(roomConfig, gameMode) {
            if (!currentUserId) {
                showCustomAlert("Errore", "Autenticazione non riuscita. Riprova.");
                return;
            }
            const finalCast = [...castData].sort(() => 0.5 - Math.random()).slice(0, roomConfig.numContestants);
            const initialHumanPlayer = {
                nickname: localPlayerInfo.nickname,
                img: localPlayerInfo.img,
                characterName: null,
                isHost: true,
                friends: [], allies: [], enemies: []
            };
            const newGameState = {
                hostId: currentUserId,
                gameMode: gameMode,
                phase: 'LOBBY',
                roomConfig: roomConfig,
                finalCast: finalCast,
                humanPlayers: { [currentUserId]: initialHumanPlayer },
                episode: 1,
                isMerged: false,
                teams: [],
                individualPlayers: [],
                eliminatedContestants: [],
                interactionLog: [],
                votes: {},
                currentAction: { type: null, message: "" }
            };
            try {
                const roomCollection = collection(db, "artifacts", appId, "public", "data", "rooms");
                const roomRef = await addDoc(roomCollection, {
                    ...newGameState,
                    createdAt: serverTimestamp()
                });
                joinRoom(roomRef.id);
            } catch (error) {
                console.error("Errore nella creazione della stanza: ", error);
                showCustomAlert("Errore di Rete", "Impossibile creare la stanza.");
            }
        }

        async function joinRoom(roomId) {
            if (!currentUserId) {
                showCustomAlert("Errore", "Autenticazione non riuscita. Riprova.");
                return;
            }
            currentRoomId = roomId.trim();
            if (!currentRoomId) {
                 showCustomAlert("Errore", "ID Stanza non valido.");
                 return;
            }
            const roomRef = doc(db, "artifacts", appId, "public", "data", "rooms", currentRoomId);
            try {
                 const roomSnap = await getDoc(roomRef);
                 if (!roomSnap.exists()) {
                     showCustomAlert("Errore", "Stanza non trovata.");
                     return;
                 }
                 const roomData = roomSnap.data();
                 if (!roomData.humanPlayers[currentUserId]) {
                     const newPlayer = {
                         nickname: localPlayerInfo.nickname,
                         img: localPlayerInfo.img,
                         characterName: null,
                         isHost: false,
                         friends: [], allies: [], enemies: []
                     };
                     await updateDoc(roomRef, {
                         [`humanPlayers.${currentUserId}`]: newPlayer
                     });
                 }
                 if (unsubscribeFromRoom) unsubscribeFromRoom();
                 unsubscribeFromRoom = onSnapshot(roomRef, (doc) => {
                     console.log("Dati della stanza aggiornati!");
                     gameState = doc.data();
                     if(gameState) {
                        renderGameUI();
                     }
                 });
            } catch (error) {
                console.error("Errore nell'entrare nella stanza: ", error);
                showCustomAlert("Errore di Rete", "Impossibile entrare nella stanza.");
            }
        }

        async function updateFirestoreState(newStateObject) {
            if (!currentRoomId) return;
            try {
                const roomRef = doc(db, "artifacts", appId, "public", "data", "rooms", currentRoomId);
                await updateDoc(roomRef, newStateObject);
            } catch (error) {
                console.error("Errore nell'aggiornamento dello stato: ", error);
            }
        }

        // --- FUNZIONI DI RENDER ---
        function renderGameUI() {
            document.querySelectorAll('#main-menu, #character-selection-screen, #main-game-screen').forEach(el => el.classList.add('hidden'));
            document.querySelectorAll('.modal').forEach(el => el.style.display = 'none');

            switch (gameState.phase) {
                case 'LOBBY':
                    characterSelectionScreen.classList.remove('hidden');
                    renderLobby();
                    break;
                case 'ACTION':
                case 'CHALLENGE':
                case 'VOTE':
                case 'ELIMINATION':
                case 'FINALE':
                    mainGameScreen.classList.remove('hidden');
                    renderMainGame();
                    break;
                default:
                    mainMenu.classList.remove('hidden');
            }
        }

        function renderLobby() {
            document.getElementById('room-id-display').value = currentRoomId;
            const container = document.getElementById('char-select-container');
            container.innerHTML = '';
            const takenCharacters = Object.values(gameState.humanPlayers).map(p => p.characterName).filter(Boolean);

            gameState.finalCast.forEach(character => {
                const isLocked = takenCharacters.includes(character.name) && gameState.humanPlayers[currentUserId]?.characterName !== character.name;
                const card = document.createElement('div');
                card.className = `character-card bg-white rounded-lg shadow-md p-2 text-center ${isLocked ? 'locked' : ''}`;
                card.dataset.name = character.name;
                card.innerHTML = `<img src="${character.img}" alt="${character.name}" class="w-full h-32 object-cover rounded-md mx-auto"><p class="mt-2 font-semibold text-sm text-gray-700">${character.name}</p>`;
                if (!isLocked) {
                    card.onclick = () => selectCharacter(character.name);
                }
                container.appendChild(card);
            });
            
            const myPlayer = gameState.humanPlayers[currentUserId];
            if (myPlayer && myPlayer.characterName) {
                 const selectedCard = container.querySelector(`.character-card[data-name="${myPlayer.characterName}"]`);
                 if(selectedCard) selectedCard.classList.add('selected');
            }
            updatePlayerCharList();
            
            const startGameBtn = document.getElementById('start-game-btn');
            const isHost = gameState.hostId === currentUserId;
            startGameBtn.style.display = isHost ? 'block' : 'none';
            const allPlayersReady = Object.values(gameState.humanPlayers).every(p => p.characterName);
            startGameBtn.disabled = !allPlayersReady;
        }
        
        function renderMainGame() {
            episodeTitle.textContent = `Episodio ${gameState.episode}`;
            gameStatusText.textContent = gameState.currentAction?.message || "Inizia un nuovo episodio!";
            updateContestantsUI();
            updatePlayerStatusCards();
            updateEliminationRanking();
            updateInteractionLogUI();
            updateHostPanel();
            updatePlayerActions();
        }

        function updateHostPanel() {
            const isHost = gameState.hostId === currentUserId;
            const hostPanel = document.getElementById('host-panel');
            const nextStepBtn = document.getElementById('next-step-btn');
            const hostInstructions = document.getElementById('host-instructions');

            hostPanel.style.display = isHost ? 'block' : 'none';
            if (!isHost) return;

            let instructionText = "";
            let buttonText = "Procedi";
            let buttonAction = () => runGameCycle();
            nextStepBtn.disabled = false;

            switch(gameState.phase) {
                case 'ACTION':
                    instructionText = "In attesa che i giocatori completino le loro azioni.";
                    const playersToAct = Object.keys(gameState.humanPlayers).filter(id => !isPlayerEliminated(gameState.humanPlayers[id].characterName));
                    const playersWhoActed = Object.keys(gameState.actions || {});
                    if(playersWhoActed.length >= playersToAct.length) {
                         instructionText = "Tutti i giocatori hanno agito. Procedi alla sfida.";
                         buttonAction = () => runChallenge();
                    } else {
                        nextStepBtn.disabled = true;
                    }
                    break;
                case 'CHALLENGE':
                    instructionText = "La sfida è terminata. Procedi con le votazioni.";
                    buttonAction = () => startVoting();
                    break;
                case 'VOTE':
                     instructionText = "In attesa dei voti.";
                     const voters = getVoters();
                     const votesCast = Object.keys(gameState.votes || {});
                     if (votesCast.length >= voters.length) {
                         instructionText = "Tutti hanno votato. Procedi con l'eliminazione.";
                         buttonAction = () => conductElimination();
                     } else {
                         nextStepBtn.disabled = true;
                     }
                    break;
                case 'ELIMINATION':
                    instructionText = "La cerimonia sta per iniziare.";
                    buttonAction = () => runEliminationCeremony();
                    break;
                 case 'FINALE':
                    instructionText = "La partita è finita!";
                    nextStepBtn.disabled = true;
                    break;
            }
            hostInstructions.textContent = instructionText;
            nextStepBtn.textContent = buttonText;
            nextStepBtn.onclick = buttonAction;
        }

        function updatePlayerActions() {
            const myPlayer = gameState.humanPlayers[currentUserId];
            if (!myPlayer || isPlayerEliminated(myPlayer.characterName)) {
                return; // Giocatore non trovato o eliminato
            }

            if (gameState.phase === 'ACTION' && !(gameState.actions && gameState.actions[currentUserId])) {
                actionPhaseModal.style.display = 'block';
            }
            if (gameState.phase === 'VOTE' && !(gameState.votes && gameState.votes[currentUserId])) {
                const voters = getVoters();
                if (voters.some(v => v.name === myPlayer.characterName)) {
                    openVotingModalForPlayer();
                }
            }
        }

        // --- LOGICA DI GIOCO SINCRONIZZATA ---

        function runGameCycle() {
            if (currentUserId !== gameState.hostId) return;

            const allCurrentPlayers = allPlayers();
            if (allCurrentPlayers.length <= 2 && gameState.phase !== 'FINALE') {
                startFinale();
                return;
            }
            
            // La logica di merge e comeback può essere gestita qui prima di passare alla fase successiva
            const activeTeams = gameState.teams.filter(team => team.members.length > 0);
            if (!gameState.isMerged && (gameState.episode >= gameState.roomConfig.mergeEpisode || activeTeams.length <= 1)) {
                mergeTeams();
                return;
            }

            switch (gameState.phase) {
                case 'SETUP':
                case 'ELIMINATION': // Dopo un'eliminazione, si prepara il nuovo episodio
                    prepareNextEpisode();
                    break;
                case 'ACTION':
                    runChallenge();
                    break;
                case 'CHALLENGE':
                    startVoting();
                    break;
                case 'VOTE':
                    conductElimination();
                    break;
            }
        }

        function mergeTeams() {
            if (currentUserId !== gameState.hostId) return;
            const allRemainingPlayers = gameState.teams.flatMap(team => team.members);
            updateFirestoreState({
                isMerged: true,
                individualPlayers: allRemainingPlayers,
                teams: [],
                phase: 'CHALLENGE',
                currentAction: { type: 'merge', message: "I TEAM SONO STATI UNITI! Da ora è ogni concorrente per sé!" }
            });
        }

        function runChallenge() {
            if (currentUserId !== gameState.hostId) return;
            let immuneContestants = [];
            let losingTeamIndex = -1;
            let message = "";

            if (gameState.isMerged) {
                const winner = gameState.individualPlayers[Math.floor(Math.random() * gameState.individualPlayers.length)];
                immuneContestants.push(winner.name);
                message = `${winner.name} vince la sfida e ottiene l'immunità!`;
            } else {
                const activeTeams = gameState.teams.filter(team => team.members.length > 0);
                if (activeTeams.length >= 2) {
                    const shuffledTeams = [...activeTeams].sort(() => 0.5 - Math.random());
                    const winningTeam = shuffledTeams[0];
                    const losingTeam = shuffledTeams[shuffledTeams.length - 1];
                    losingTeamIndex = gameState.teams.findIndex(t => t.name === losingTeam.name);
                    message = `La Squadra ${winningTeam.name} vince la sfida! La Squadra ${losingTeam.name} andrà alla cerimonia.`;
                } else {
                    message = `La sfida è annullata per mancanza di squadre.`;
                }
            }
            updateFirestoreState({
                immuneContestants: immuneContestants,
                losingTeamIndex: losingTeamIndex,
                phase: 'CHALLENGE',
                currentAction: { type: 'challengeResult', message: message }
            });
        }

        function startVoting() {
            if (currentUserId !== gameState.hostId) return;
            updateFirestoreState({
                phase: 'VOTE',
                votes: {}, // Resetta i voti per il nuovo turno
                currentAction: { type: 'voteStart', message: "Inizia la votazione! I giocatori a rischio devono votare." }
            });
        }
        
        async function submitVote(votedPlayerName) {
            votingModal.style.display = 'none';
            await updateFirestoreState({
                [`votes.${currentUserId}`]: votedPlayerName
            });
            showCustomAlert("Voto Registrato", `Hai votato per ${votedPlayerName}.`);
        }

        function conductElimination() {
            if (currentUserId !== gameState.hostId) return;
            const votes = {};
            const candidates = getVotingCandidates();
            candidates.forEach(c => { votes[c.name] = { count: 0, voters: [] }; });

            // Simula voti AI
            const voters = getVoters();
            voters.forEach(voter => {
                const isHuman = Object.values(gameState.humanPlayers).some(p => p.characterName === voter.name);
                if (isHuman) {
                    const humanPlayerId = Object.keys(gameState.humanPlayers).find(id => gameState.humanPlayers[id].characterName === voter.name);
                    const humanVote = gameState.votes[humanPlayerId];
                    if(humanVote && votes[humanVote]) {
                        votes[humanVote].count++;
                        votes[humanVote].voters.push(voter.name);
                    }
                } else { // Voto AI
                    let votingPool = candidates.filter(c => c.name !== voter.name);
                    if (votingPool.length > 0) {
                        const finalVote = votingPool[Math.floor(Math.random() * votingPool.length)].name;
                        if (votes[finalVote]) {
                            votes[finalVote].count++;
                            votes[finalVote].voters.push(voter.name);
                        }
                    }
                }
            });

            let maxVotes = -1;
            let tiedCandidates = [];
            for (const name in votes) {
                if (votes[name].count > maxVotes) {
                    maxVotes = votes[name].count;
                    tiedCandidates = [name];
                } else if (votes[name].count === maxVotes && maxVotes > 0) {
                    tiedCandidates.push(name);
                }
            }

            const eliminatedName = tiedCandidates.length > 0 ? tiedCandidates[0] : candidates[Math.floor(Math.random() * candidates.length)].name;

            updateFirestoreState({
                phase: 'ELIMINATION',
                eliminationData: { eliminatedName: eliminatedName, votes: votes },
                currentAction: { type: 'eliminationStart', message: "I voti sono stati contati. È il momento della cerimonia." }
            });
        }
        
        async function runEliminationCeremony() {
            if (currentUserId !== gameState.hostId) return;
            
            const { eliminatedName, votes } = gameState.eliminationData;
            const eliminatedPlayer = allPlayers(false).find(p => p.name === eliminatedName);
            
            // La logica di animazione rimane lato client, ma l'aggiornamento dello stato è centralizzato
            // Qui mostriamo solo il risultato finale per semplicità
            
            const newEliminatedList = [...gameState.eliminatedContestants, { ...eliminatedPlayer, eliminatedInEpisode: gameState.episode }];
            let newTeams = [...gameState.teams];
            let newIndividuals = [...gameState.individualPlayers];

            if (gameState.isMerged) {
                newIndividuals = newIndividuals.filter(p => p.name !== eliminatedName);
            } else {
                newTeams.forEach(team => {
                    team.members = team.members.filter(m => m.name !== eliminatedName);
                });
            }

            await updateFirestoreState({
                eliminatedContestants: newEliminatedList,
                teams: newTeams,
                individualPlayers: newIndividuals,
                currentAction: { type: 'eliminationResult', message: `${eliminatedName} è stato/a eliminato/a!` }
            });

            // Dopo un breve ritardo, passa al prossimo episodio
            setTimeout(prepareNextEpisode, 4000);
        }

        function prepareNextEpisode() {
            if (currentUserId !== gameState.hostId) return;
            updateFirestoreState({
                episode: gameState.episode + 1,
                phase: gameState.gameMode === 'contestant' ? 'ACTION' : 'CHALLENGE',
                immuneContestants: [],
                actions: {}, // Resetta le azioni
                votes: {}, // Resetta i voti
                eliminationData: {},
                currentAction: { type: 'newEpisode', message: `Benvenuti all'episodio ${gameState.episode + 1}!` }
            });
        }
        
        async function handleInteraction(type, targetName) {
            interactionModal.style.display = 'none';
            // Qui un giocatore aggiorna la propria azione
            await updateFirestoreState({
                [`actions.${currentUserId}`]: { type, targetName }
            });
            showCustomAlert("Azione Registrata", `La tua azione (${type}) verso ${targetName} è stata registrata.`);
        }

        // --- FUNZIONI HELPER ---
        function allPlayers(includeDetails = false) {
             if (!gameState.teams && !gameState.individualPlayers) return [];
             const players = gameState.isMerged ? gameState.individualPlayers : gameState.teams.flatMap(t => t.members);
             if (!includeDetails) return players;

             return players.map(p => {
                 const playerId = Object.keys(gameState.humanPlayers).find(id => gameState.humanPlayers[id].characterName === p.name);
                 return {
                     name: p.name,
                     details: p,
                     isHuman: !!playerId,
                     playerId: playerId,
                     data: gameState.aiData?.[p.name] || {}
                 }
             });
        }
        function isPlayerEliminated(characterName) {
            return gameState.eliminatedContestants.some(p => p.name === characterName);
        }
        function getVoters() {
            if (gameState.isMerged) {
                return allPlayers(false);
            }
            if (gameState.losingTeamIndex !== -1 && gameState.teams[gameState.losingTeamIndex]) {
                return gameState.teams[gameState.losingTeamIndex].members;
            }
            return [];
        }
        function getVotingCandidates() {
            if (gameState.isMerged) {
                return gameState.individualPlayers.filter(p => !gameState.immuneContestants.includes(p.name));
            }
            if (gameState.losingTeamIndex !== -1 && gameState.teams[gameState.losingTeamIndex]) {
                return gameState.teams[gameState.losingTeamIndex].members;
            }
            return [];
        }
        function openVotingModalForPlayer() {
            const votingContainer = document.getElementById('voting-candidates-container');
            votingContainer.innerHTML = '';
            const candidates = getVotingCandidates();
            const myCharacterName = gameState.humanPlayers[currentUserId].characterName;

            candidates.filter(c => c.name !== myCharacterName).forEach(candidate => {
                const card = document.createElement('div');
                card.className = 'character-card bg-white rounded-lg shadow-md p-2 text-center';
                card.innerHTML = `<img src="${candidate.img}" alt="${candidate.name}" class="w-full h-32 object-cover rounded-md mx-auto pointer-events-none"><p class="mt-2 font-semibold text-sm text-gray-700 pointer-events-none">${candidate.name}</p>`;
                card.onclick = () => submitVote(candidate.name);
                votingContainer.appendChild(card);
            });
            votingModal.style.display = 'block';
        }
        
        // --- EVENT LISTENERS ---
        document.addEventListener('DOMContentLoaded', async () => {
            // Inizializzazione delle variabili DOM
            mainMenu = document.getElementById('main-menu');
            mainGameScreen = document.getElementById('main-game-screen');
            characterSelectionScreen = document.getElementById('character-selection-screen');
            modeSelectionModal = document.getElementById('mode-selection-modal');
            createRoomModal = document.getElementById('create-room-modal');
            actionPhaseModal = document.getElementById('action-phase-modal');
            interactionModal = document.getElementById('interaction-modal');
            votingModal = document.getElementById('voting-modal');
            ceremonyModal = document.getElementById('elimination-ceremony-modal');
            tieBreakerModal = document.getElementById('tie-breaker-modal');
            nextStepBtn = document.getElementById('next-step-btn');
            skipCeremonyBtn = document.getElementById('skip-ceremony-btn');
            episodeTitle = document.getElementById('episode-title');
            gameStatusText = document.getElementById('game-status-text');
            hostInstructions = document.getElementById('host-instructions');
            customAlertModal = document.getElementById('custom-alert-modal');
            
            // Autenticazione utente
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                 console.error("Authentication failed:", error);
                 showCustomAlert("Errore di Autenticazione", "Impossibile connettersi. Ricarica la pagina.");
            }

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    currentUserId = user.uid;
                } else {
                    currentUserId = null;
                }
            });

            // Gestione creazione stanza
            document.getElementById('confirm-create-room').onclick = () => {
                const roomConfig = {
                    numContestants: parseInt(document.getElementById('num-contestants').value, 10),
                    mergeEpisode: parseInt(document.getElementById('merge-episode').value, 10),
                    teamNames: Array.from(document.querySelectorAll('.team-name-input')).map(input => input.value),
                    comebacks: [],
                };
                localPlayerInfo.nickname = document.getElementById('nickname').value;
                localPlayerInfo.img = document.getElementById('player-image-preview').src;
                createRoom(roomConfig, gameState.gameMode);
                createRoomModal.style.display = 'none';
            };

            // Gestione entrata in stanza
            document.getElementById('join-room-btn').onclick = () => {
                const roomId = document.getElementById('room-id-input').value;
                if (roomId) {
                    localPlayerInfo.nickname = document.getElementById('nickname').value;
                    localPlayerInfo.img = document.getElementById('player-image-preview').src;
                    joinRoom(roomId);
                } else {
                    showCustomAlert("Errore", "Inserisci un ID Stanza.");
                }
            };
            
            document.getElementById('start-game-btn').onclick = () => {
                if(currentUserId === gameState.hostId) initializeGame();
            };

            document.getElementById('copy-room-id-btn').onclick = () => {
                const roomIdInput = document.getElementById('room-id-display');
                roomIdInput.select();
                try {
                    document.execCommand('copy');
                    showCustomAlert("Copiato!", "L'ID della stanza è stato copiato negli appunti.");
                } catch (err) {
                    showCustomAlert("Errore", "Impossibile copiare l'ID.");
                }
            };
            
            document.getElementById('action-interact').onclick = () => openInteractionModal('interact');
            document.getElementById('action-sabotage').onclick = () => openInteractionModal('sabotage');
            document.getElementById('action-nothing').onclick = async () => {
                 actionPhaseModal.style.display = 'none';
                 await updateFirestoreState({ [`actions.${currentUserId}`]: { type: 'nothing' } });
                 showCustomAlert("Azione Registrata", "Hai deciso di non fare nulla.");
            };

            document.getElementById('open-mode-selection-btn').onclick = () => {
                if (modeSelectionModal) modeSelectionModal.style.display = 'block';
            };
            document.getElementById('select-judge-mode').onclick = () => {
                gameState.gameMode = 'judge';
                if (modeSelectionModal) modeSelectionModal.style.display = 'none';
                if (createRoomModal) createRoomModal.style.display = 'block';
            };
            document.getElementById('select-contestant-mode').onclick = () => {
                gameState.gameMode = 'contestant';
                if (modeSelectionModal) modeSelectionModal.style.display = 'none';
                if (createRoomModal) createRoomModal.style.display = 'block';
            };
            document.getElementById('num-teams').onchange = (e) => {
                const num = parseInt(e.target.value, 10);
                const container = document.getElementById('team-names-container');
                container.innerHTML = '';
                for (let i = 0; i < num; i++) {
                    container.innerHTML += `<div><label class="block text-sm font-medium">Nome Squadra ${i+1}</label><input type="text" class="team-name-input w-full mt-1 border-gray-300 rounded-md" value="Squadra ${i+1}"></div>`;
                }
            };
            document.getElementById('num-teams').dispatchEvent(new Event('change'));
            document.querySelectorAll('.modal .close').forEach(el => el.onclick = () => {
                el.closest('.modal').style.display = 'none';
            });
            document.getElementById('custom-alert-close').onclick = () => {
                 if (customAlertModal) customAlertModal.style.display = 'none';
            };
        });
        
        // --- Funzioni UI non modificate (ma necessarie) ---
        function showCustomAlert(title, message) {
            document.getElementById('custom-alert-title').textContent = title;
            document.getElementById('custom-alert-message').textContent = message;
            if (customAlertModal) customAlertModal.style.display = 'block';
        }
        async function selectCharacter(charName) {
            const roomRef = doc(db, "artifacts", appId, "public", "data", "rooms", currentRoomId);
            await updateDoc(roomRef, {
                [`humanPlayers.${currentUserId}.characterName`]: charName
            });
        }
        function updatePlayerCharList() {
            const list = document.getElementById('player-char-list');
            list.innerHTML = '';
            if (!gameState.humanPlayers) return;
            for (const playerId in gameState.humanPlayers) {
                const player = gameState.humanPlayers[playerId];
                const isCurrentUser = playerId === currentUserId;
                const playerHtml = `<div class="flex items-center p-2 rounded-lg ${isCurrentUser ? 'bg-blue-100' : 'bg-gray-100'}">
                    <img src="${player.img}" class="w-10 h-10 rounded-full object-cover mr-3">
                    <div>
                        <p class="font-bold">${player.nickname} ${player.isHost ? '(Host)' : ''}</p>
                        <p class="text-sm text-gray-600">${player.characterName || 'Scegliendo...'}</p>
                    </div>
                </div>`;
                list.innerHTML += playerHtml;
            }
        }
        async function initializeGame() {
            if (currentUserId !== gameState.hostId) return;
            let teams = [];
            let aiData = {};
            if (gameState.gameMode === 'judge') {
                const shuffledCast = [...gameState.finalCast].sort(() => 0.5 - Math.random());
                teams = gameState.roomConfig.teamNames.map(name => ({ name: name, members: [] }));
                shuffledCast.forEach((member, index) => teams[index % gameState.roomConfig.teamNames.length].members.push(member));
            } else {
                const humanCharacters = Object.values(gameState.humanPlayers).map(p => p.characterName);
                const castForGame = gameState.finalCast.filter(c => !humanCharacters.includes(c.name));
                const humanCharacterDetails = Object.values(gameState.humanPlayers).map(p => gameState.finalCast.find(c => c.name === p.characterName));
                castForGame.forEach(c => { aiData[c.name] = { friendsWith: [], alliedWith: null }; });
                const shuffledCast = [...castForGame].sort(() => 0.5 - Math.random());
                teams = gameState.roomConfig.teamNames.map(name => ({ name: name, members: [] }));
                const allParticipants = [...humanCharacterDetails, ...shuffledCast];
                allParticipants.forEach((member, index) => {
                    teams[index % gameState.roomConfig.teamNames.length].members.push(member);
                });
            }
            await updateFirestoreState({
                phase: 'SETUP', // Fase intermedia prima del primo episodio
                teams: teams,
                aiData: aiData,
            });
            runGameCycle(); // L'host avvia il primo ciclo
        }
        function updateContestantsUI() {
            const teamsContainer = document.getElementById('teams-container');
            teamsContainer.innerHTML = '';
            const createCardHTML = (member) => {
                const isImmune = gameState.immuneContestants?.includes(member.name);
                const playerInfo = Object.values(gameState.humanPlayers).find(p => p.characterName === member.name);
                return `<div class="character-card disabled bg-white rounded-lg shadow-md p-2 text-center ${isImmune ? 'immune-aura' : ''} ${playerInfo ? 'player-controlled' : ''}">
                    <img src="${member.img}" alt="${member.name}" class="w-full h-32 object-cover rounded-md mx-auto">
                    <p class="mt-2 font-semibold text-sm text-gray-700">${member.name}</p>
                    ${playerInfo ? `<p class="text-xs text-blue-600 font-bold">${playerInfo.nickname}</p>` : ''}
                </div>`;
            };
            if (gameState.isMerged) {
                const container = document.createElement('div');
                container.className = `team-container p-4 rounded-xl shadow-lg w-full bg-gray-200`;
                let membersHtml = gameState.individualPlayers.map(createCardHTML).join('');
                container.innerHTML = `<h3 class="text-2xl font-bold text-center mb-4 text-gray-900">Concorrenti Individuali</h3><div class="grid grid-cols-2 sm:grid-cols-4 lg:grid-cols-6 gap-3">${membersHtml}</div>`;
                teamsContainer.appendChild(container);
            } else if (gameState.teams) {
                const teamColors = ['bg-blue-200', 'bg-red-200', 'bg-green-200', 'bg-yellow-200', 'bg-purple-200', 'bg-pink-200'];
                gameState.teams.forEach((team, index) => {
                    if (team.members.length === 0) return;
                    const teamEl = document.createElement('div');
                    teamEl.className = `team-container p-4 rounded-xl shadow-lg w-full md:w-5/12 ${teamColors[index % teamColors.length]}`;
                    let membersHtml = team.members.map(createCardHTML).join('');
                    teamEl.innerHTML = `<h3 class="text-2xl font-bold text-center mb-4 text-gray-900">${team.name}</h3><div class="grid grid-cols-2 lg:grid-cols-3 gap-3">${membersHtml}</div>`;
                    teamsContainer.appendChild(teamEl);
                });
            }
        }
        function updatePlayerStatusCards() {
            const statusContainer = document.getElementById('player-status-container');
            statusContainer.innerHTML = '';
            if (!gameState.humanPlayers) return;
            Object.values(gameState.humanPlayers).forEach(player => {
                const isEliminated = isPlayerEliminated(player.characterName);
                const statusHTML = `<div class="flex items-center p-2 bg-gray-100 rounded-lg shadow-sm ${isEliminated ? 'filter grayscale' : ''}">
                    <img src="${player.img}" class="w-12 h-12 rounded-full object-cover mr-4">
                    <div class="flex-grow">
                        <p class="font-bold text-gray-800">${player.nickname}</p>
                        <p class="text-sm text-gray-600">Controlla: ${player.characterName || 'N/A'}</p>
                    </div>
                    <div class="text-right">
                        <p class="text-sm font-semibold ${isEliminated ? 'text-red-600' : 'text-green-600'}">${isEliminated ? `Eliminato` : 'In Gioco'}</p>
                    </div>
                </div>`;
                statusContainer.innerHTML += statusHTML;
            });
        }
        function updateEliminationRanking() {
            const rankingList = document.getElementById('elimination-ranking-list');
            rankingList.innerHTML = '';
            if (gameState.eliminatedContestants && gameState.eliminatedContestants.length > 0) {
                gameState.eliminatedContestants.forEach((eliminated) => {
                    const card = document.createElement('div');
                    card.className = "text-center text-white";
                    card.innerHTML = `<img src="${eliminated.img}" class="w-16 h-16 rounded-full object-cover mx-auto border-2 border-red-700 filter grayscale"><p class="text-sm font-semibold mt-1 drop-shadow-lg">${eliminated.name}</p>`;
                    rankingList.appendChild(card);
                });
            } else {
                rankingList.innerHTML = '<p class="text-gray-200 text-sm">Nessun eliminato ancora.</p>';
            }
        }
        function updateInteractionLogUI() {
            const logContainer = document.getElementById('interaction-log');
            logContainer.innerHTML = '';
            if (!gameState.interactionLog || gameState.interactionLog.length === 0) {
                logContainer.innerHTML = '<p class="text-gray-500">Nessuna interazione ancora.</p>';
                return;
            }
            [...gameState.interactionLog].reverse().forEach(log => {
                const p = document.createElement('p');
                p.innerHTML = `<span class="font-semibold text-gray-500">Ep.${log.episode}:</span> ${log.text}`;
                logContainer.appendChild(p);
            });
        }
        function openInteractionModal(type) {
            actionPhaseModal.style.display = 'none';
            const container = document.getElementById('interaction-candidates-container');
            const modal = document.getElementById('interaction-modal');
            modal.querySelector('h2').textContent = type === 'interact' ? 'Interagisci con...' : 'Sabota...';
            container.innerHTML = '';
            const myCharacterName = gameState.humanPlayers[currentUserId].characterName;
            const aiPlayers = allPlayers(false).filter(p => {
                const isHuman = Object.values(gameState.humanPlayers).some(hp => hp.characterName === p.name);
                return !isHuman && p.name !== myCharacterName;
            });
            aiPlayers.forEach(ai => {
                const card = document.createElement('div');
                card.className = 'character-card bg-white rounded-lg shadow-md p-2 text-center';
                card.innerHTML = `<img src="${ai.img}" class="w-full h-32 object-cover rounded-md mx-auto"><p class="mt-2 font-semibold text-sm text-gray-700">${ai.name}</p><button class="w-full mt-2 px-2 py-1 text-xs text-white rounded bg-blue-500">Scegli</button>`;
                card.querySelector('button').onclick = () => handleInteraction(type, ai.name);
                container.appendChild(card);
            });
            modal.style.display = 'block';
        }
    </script>
</body>
</html>
