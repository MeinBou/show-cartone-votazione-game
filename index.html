<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Total Drama Online</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Import Map per React e Firebase -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "firebase/app": "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js",
        "firebase/auth": "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js",
        "firebase/firestore": "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js",
        "lucide-react": "https://esm.sh/lucide-react@0.294.0"
      }
    }
    </script>
    
    <!-- Babel Standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body { -webkit-overflow-scrolling: touch; } 
        /* Hide scrollbar for Chrome, Safari and Opera */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        /* Hide scrollbar for IE, Edge and Firefox */
        .no-scrollbar {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
    </style>
</head>
<body class="bg-slate-900 text-white">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useMemo } from 'react';
        import { createRoot } from 'react-dom/client';
        import { initializeApp } from 'firebase/app';
        import { 
          getAuth, 
          signInAnonymously, 
          onAuthStateChanged,
          signInWithCustomToken
        } from 'firebase/auth';
        import { 
          getFirestore, 
          collection, 
          doc, 
          setDoc, 
          getDoc, 
          updateDoc, 
          onSnapshot, 
          arrayUnion,
          serverTimestamp,
          deleteDoc,
          getDocs // Importato getDocs per la pulizia
        } from 'firebase/firestore';
        import { 
          Heart, Users, Play, LogOut, MessageSquare, Skull, 
          Trophy, Crown, UserPlus, Shield, Swords, Flame, 
          AlertTriangle, ArrowRight, Dices, Send, X, Vote, ListOrdered, Coffee, ChevronDown, Award, CheckCircle, Undo2,
          Package, Gem, Lock, Unlock, Target, Users2, AlertOctagon, Shuffle
        } from 'lucide-react';

        // --- TUE CHIAVI FIREBASE INSERITE ---
        const MANUAL_CONFIG = {
            apiKey: "AIzaSyBm_dLeu-Q6TwvTxmS9gyXAQxXqQHRF2GA",
            authDomain: "td-interaction.firebaseapp.com",
            projectId: "td-interaction",
            storageBucket: "td-interaction.firebasestorage.app",
            messagingSenderId: "916995350556",
            appId: "1:916995350556:web:accd878a4497c862107fd9"
        };

        const getFirebaseConfig = () => {
            return MANUAL_CONFIG;
        };

        const getAppId = () => {
            return "total-drama-public-game"; 
        };

        const firebaseConfig = getFirebaseConfig();

        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            console.log("Firebase collegato con successo!");
        } catch (error) {
            console.error("Errore inizializzazione Firebase:", error);
        }

        const appId = getAppId();

        // --- COSTANTI ---
        const TEN_MINUTES_MS = 10 * 60 * 1000;
        
        const SEASON_CONFIG = [
          { name: "L'Isola", bg: "https://images.unsplash.com/photo-1507525428034-b723cf961d3e?q=80&w=2073&auto=format&fit=crop", theme: "Spiaggia" },
          { name: "Azione", bg: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTRHA0Qhs3YuQ2N8cZ-Vp0s5FuDeC0x4zwNqg&s", theme: "Cinema" },
          { name: "World Tour", bg: "https://images.unsplash.com/photo-1559586616-361e18714958?q=80&w=2070&auto=format&fit=crop", theme: "Aereo" }
        ];

        const ROSTER = [
          { name: "Lord Farquaad", img: "https://i.pinimg.com/736x/35/93/ac/3593acb0b8f9d75704f5a0778c693e73.jpg" },
          { name: "Marinette", img: "https://i.pinimg.com/736x/b8/74/55/b87455575cd069609007a639c9490293.jpg" },
          { name: "Adrien", img: "https://i.pinimg.com/1200x/5c/2d/c7/5c2dc740ed2fe906b6afaf1320bf4273.jpg" },
		  { name: "Alya", img: "https://i.pinimg.com/736x/3e/3b/99/3e3b99fc26e6b2cb8bf7359c53acca24.jpg" },
		  { name: "Luka", img: "https://i.pinimg.com/736x/16/40/f3/1640f3c6c2b14e00c110316e02e86c7f.jpg" },
		  { name: "Kagami", img: "https://i.pinimg.com/736x/56/e2/ad/56e2adc6421c613a6d00b393abd1a6c1.jpg" },
          { name: "Re Julien", img: "https://i.pinimg.com/736x/1e/17/19/1e17194ef5b383e4202fbb4875cfbd81.jpg" },
          { name: "Skipper", img: "https://i.pinimg.com/736x/e6/f0/5b/e6f05b20dda962344721db983c882679.jpg" },
          { name: "Gwen", img: "https://i.pinimg.com/1200x/59/d7/15/59d71578cd5f889ae898bbc83dda29dc.jpg" },
          { name: "Julia", img: "https://i.pinimg.com/736x/80/c2/83/80c283f82be806cdd40e71d303d09474.jpg" },
          { name: "Duncan", img: "https://i.pinimg.com/736x/3f/2d/e1/3f2de1cd71448e1413ab3ccafbed5b4d.jpg" },
          { name: "Conan", img: "https://i.pinimg.com/736x/19/fe/f0/19fef0cf0b848e1f5fe54d9b641af4ce.jpg" },
          { name: "Ran", img: "https://i.pinimg.com/1200x/46/ee/c7/46eec75f3a3eeb4846216dfdd7083ff4.jpg" },
          { name: "Rias", img: "https://i.pinimg.com/736x/d1/a7/df/d1a7df7bfe5769c39e9b66041144e4eb.jpg" },
          { name: "Bayonetta", img: "https://i.pinimg.com/1200x/60/fc/c0/60fcc064dc97d24b96a9517f726c1970.jpg" },
          { name: "Yoshi", img: "https://i.pinimg.com/736x/f3/05/7f/f3057f14de68b0afe682ffe93dcc479b.jpg" },
          { name: "Rosalinda", img: "https://i.pinimg.com/736x/09/14/f0/0914f029e712e92de9d4f0081a5da032.jpg" },
		  { name: "Peach", img: "https://i.pinimg.com/736x/c0/53/fb/c053fb4dd4f8c0dd9c277212490b1962.jpg" },
		  { name: "Daisy", img: "https://i.pinimg.com/736x/e2/47/61/e2476198364b030d3a8f9a1f93becfb9.jpg" },
		  { name: "Pauline", img: "https://i.pinimg.com/736x/86/83/ee/8683ee7c89735311e61addebf517a3de.jpg" },
		  { name: "Wario", img: "https://i.pinimg.com/736x/2f/ea/be/2feabe47151fd436fbf358c299eb4870.jpg" },
          { name: "Brago", img: "https://i.pinimg.com/736x/c6/75/2d/c6752dab1b78e4c4adc64b6ffd09b755.jpg" },
          { name: "Ponygon", img: "https://i.pinimg.com/736x/53/e4/fb/53e4fb1c1f8964ca949c4e72663edd8f.jpg" },
          { name: "Steven", img: "https://i.pinimg.com/736x/2b/fd/20/2bfd202ab782611ea6a0fb0cdcdc37ab.jpg" },
          { name: "Perla", img: "https://i.pinimg.com/1200x/bf/d3/78/bfd378c4c8921a30ee00cf48bdb7fa11.jpg" },
		  { name: "Lapis", img: "https://i.pinimg.com/736x/88/0f/a5/880fa555f1f954dbca08aded1be846d2.jpg" },
          { name: "Ametista", img: "https://i.pinimg.com/736x/b4/e4/45/b4e445061d31ec75fa4ee63e20ebf87e.jpg" },
          { name: "Nicole", img: "https://i.pinimg.com/736x/81/24/e4/8124e43da43e1d06dcdbca15f22a0cd9.jpg" },
          { name: "Gumball", img: "https://i.pinimg.com/736x/ae/88/e3/ae88e329120b3edc196af1ebbfd8fe07.jpg" },
          { name: "Anais", img: "https://i.pinimg.com/736x/0a/8b/ab/0a8bab3e6151e894a2d9b96749d63e61.jpg" },
          { name: "Lisa", img: "https://i.pinimg.com/736x/e5/2d/fe/e52dfee5a58f5dad19f9e0592c63a7cd.jpg" },
          { name: "Bart", img: "https://i.pinimg.com/1200x/cf/dc/86/cfdc8641fb98a49c0e731a8e6c002b02.jpg" },
          { name: "Marge", img: "https://i.pinimg.com/736x/77/6d/41/776d41748c4c9ae5940d8a9b10db881a.jpg" },
          { name: "Ned", img: "https://i.pinimg.com/1200x/4e/12/0e/4e120eb01e572b2ad08af6552214ce82.jpg" },
          { name: "Neera", img: "https://i.pinimg.com/736x/49/15/3c/49153c31d0b41814b3c862a98d848b40.jpg" },
          { name: "Perry", img: "https://i.pinimg.com/736x/3e/02/28/3e02284ed84c86d445b3bee5639c81f6.jpg" },
          { name: "Nonnina", img: "https://i.pinimg.com/736x/c0/82/61/c08261487f081ba5ed490c5dc317b112.jpg" },
          { name: "Sid", img: "https://i.pinimg.com/1200x/69/4a/0e/694a0eeaf3c1182a15263d580cd0f7eb.jpg" },
          { name: "Diego", img: "https://i.pinimg.com/736x/56/bf/be/56bfbecae5aa54c2dd6ee8620fc66361.jpg" },
          { name: "Alex", img: "https://i.pinimg.com/1200x/2d/c2/4c/2dc24cfae5fe2848bc8bdd1f684d1c8d.jpg" },
          { name: "Corvina GO", img: "https://i.pinimg.com/736x/92/91/db/9291dbef281abc1f05e709c94fe17eba.jpg" },
          { name: "Corvina TT", img: "https://i.pinimg.com/736x/b8/09/d1/b809d102bfdc848380a4d73e94fe7769.jpg" },
          { name: "Stellarubia GO", img: "https://i.pinimg.com/736x/b8/7f/35/b87f358405b6d516a3e6321709aa4884.jpg" },
          { name: "Robin TT", img: "https://i.pinimg.com/736x/cd/57/18/cd57186e05d47ef5f75bef6f0a33f59c.jpg" },
          { name: "Nightwing", img: "https://i.pinimg.com/736x/47/bc/ce/47bcceac6b573a1b8277b6a75f0a4b55.jpg" },
          { name: "Robin GO", img: "https://i.pinimg.com/736x/92/b6/50/92b650adbe57c5cec55a3ef46b65e933.jpg" },
          { name: "Johnny Bravo", img: "https://i.pinimg.com/736x/4a/62/70/4a6270678f7adcf130672bcd0af41fdf.jpg" },
          { name: "Daphne", img: "https://i.pinimg.com/736x/aa/91/39/aa9139e32492a07712926dbd0db0b521.jpg" },
          { name: "Shaggy", img: "https://i.pinimg.com/1200x/0e/46/70/0e46703bcf03ff84420b0b71474c9ed7.jpg" },
          { name: "Francine", img: "https://i.pinimg.com/736x/b3/b5/f6/b3b5f6849a52b4daed92424650a98f7f.jpg" },
          { name: "Hayley", img: "https://i.pinimg.com/originals/9d/58/70/9d58707a635942c60ee7fd1afc8403bd.gif" },
          { name: "Stan", img: "https://i.pinimg.com/736x/cc/48/c0/cc48c09c661d4f9af432a37c6b908e41.jpg" },
          { name: "Stewie", img: "https://i.pinimg.com/1200x/1e/a2/cc/1ea2cc7a197e3841086f4a1ce18b089c.jpg" },
          { name: "Lois", img: "https://i.pinimg.com/736x/6e/f7/42/6ef74238d3938c8e02f62c54fa7fb4c5.jpg" },
          { name: "Peter", img: "https://i.pinimg.com/736x/9e/40/74/9e4074bbe7890cd245b51b9ff5c0e33c.jpg" },
          { name: "Fry", img: "https://i.pinimg.com/736x/d6/f4/ac/d6f4acc1bfae65c673b4b5e02a89ce71.jpg" },
          { name: "Leela", img: "https://i.pinimg.com/736x/e9/b2/71/e9b27128376e5b5f23aaafdc9956bd50.jpg" },
          { name: "Kim", img: "https://i.pinimg.com/736x/5d/7d/55/5d7d55fec8f9d8fb81e9db4438235f71.jpg" },
          { name: "Tess", img: "https://i.pinimg.com/736x/3f/bc/a9/3fbca9cb61b70f4d58c83598f0236764.jpg" },
		  { name: "Hunter", img: "https://i.pinimg.com/736x/0d/f2/73/0df2731820fb9f74774f5e8607556625.jpg" },
		  { name: "Jake DC", img: "https://i.pinimg.com/736x/bc/a0/76/bca0765eaa0f1e88b0070a5b92c22de7.jpg" },
		  { name: "Tom", img: "https://i.pinimg.com/736x/c2/21/a8/c221a8a2ae866afe53a53843efcfc05c.jpg" },
		  { name: "Ashley", img: "https://i.pinimg.com/736x/d1/c5/5f/d1c55f57218baecf0c2e160155e80c61.jpg" },
		  { name: "Timmy", img: "https://i.pinimg.com/736x/91/de/1b/91de1b5b1897a71a36957191623af776.jpg" },
		  { name: "Trixie", img: "https://i.pinimg.com/736x/05/08/a7/0508a771507d83f2b52a97467f57d581.jpg" },
		  { name: "Vicky", img: "https://i.pinimg.com/1200x/f5/1f/2e/f51f2e0bff74df3173b110f24943a6fc.jpg" },
		  { name: "Finn", img: "https://i.pinimg.com/736x/7e/0b/c9/7e0bc9826a7652264f32a44bc8a40ede.jpg" },
		  { name: "Fiona", img: "https://i.pinimg.com/1200x/0b/9d/85/0b9d85c6c70be88471ad753b014de88b.jpg" },
		  { name: "Jake", img: "https://i.pinimg.com/1200x/cd/77/22/cd7722b2f98ffc75d1128913df6861d7.jpg" },
		  { name: "Cake", img: "https://i.pinimg.com/736x/70/6c/08/706c08681ae007b24d103c44910431c1.jpg" },
		  { name: "Marceline", img: "https://i.pinimg.com/736x/3a/58/7d/3a587db4bdc947c7d3458dc9582af9cd.jpg" },
		  { name: "Zoey", img: "https://i.pinimg.com/736x/48/53/3e/48533edc4b5054ec0a7bca17130f22af.jpg" },
		  { name: "Rochelle", img: "https://i.pinimg.com/736x/bb/56/ed/bb56ed9fa63be897ba67032706d75cc7.jpg" },
		  { name: "Ellis", img: "https://i.pinimg.com/736x/be/58/d5/be58d584da6dfa953ec9be2bd0ac94ac.jpg" },
		  { name: "Tanjiro", img: "https://i.pinimg.com/736x/e9/6d/20/e96d20e7c159897a05c6baa57fac7f35.jpg" },
		  { name: "Hinosuke", img: "https://i.pinimg.com/1200x/cf/d8/27/cfd82718c3f40c906665a0d680196439.jpg" },
		  { name: "Zenitsu", img: "https://i.pinimg.com/1200x/91/12/9d/91129dee62e996da6313160605cb514d.jpg" },
		  { name: "Nezuko", img: "https://i.pinimg.com/1200x/72/b7/56/72b756ee900c26b3e616ba439e1f05c2.jpg" },
		  { name: "Shinobu", img: "https://i.pinimg.com/736x/8b/71/a5/8b71a53282f08aea93f83852a01e4e44.jpg" },
		  { name: "Tengen", img: "https://i.pinimg.com/736x/33/ef/07/33ef07083eb82a6e314b32b2d6e72295.jpg" },
		  { name: "Aang", img: "https://i.pinimg.com/736x/21/c6/02/21c60273e7409b871140d5cee2cace5b.jpg" },
		  { name: "Katara", img: "https://i.pinimg.com/736x/88/3b/a4/883ba48c5727d96962d2a93536f04c17.jpg" },
		  { name: "Toph", img: "https://i.pinimg.com/736x/54/70/77/5470771ee32d3350ffa08f921bb3d1ad.jpg" },
		  { name: "Sokka", img: "https://i.pinimg.com/736x/61/a7/91/61a7919a2c2df87b0106a425c031b9ca.jpg" },
		  { name: "Mordecai", img: "https://i.pinimg.com/736x/4f/2e/04/4f2e04cace599c4433a84b490d12c2a4.jpg" },
		  { name: "Rigby", img: "https://i.pinimg.com/736x/dd/7d/18/dd7d18fad1de3125ac14554e42f4d55f.jpg" },
		  { name: "Superboy", img: "https://i.pinimg.com/1200x/70/d3/45/70d345e2d54b002fbc96b4ae8aa255e5.jpg" },
		  { name: "Miss Martian", img: "https://i.pinimg.com/1200x/f9/8c/75/f98c75467a5002ad20a36272cfe9faa1.jpg" },
		  { name: "Zatanna", img: "https://i.pinimg.com/1200x/c9/9f/59/c99f5937cc6afce81e3298a007468992.jpg" },
		  { name: "Draculaura", img: "https://i.pinimg.com/236x/49/d8/23/49d823b49c0621162712fb43dd5bf002.jpg" },
		  { name: "Clawdeen", img: "https://i.pinimg.com/736x/fe/cb/1c/fecb1c67924cd56bb01e19deb12294f1.jpg" },
		  { name: "Frankie", img: "https://i.pinimg.com/736x/c0/ae/bb/c0aebba7d0b329e4a8e26f92d36a857a.jpg" },
		  { name: "Shego", img: "https://i.pinimg.com/736x/54/70/77/5470771ee32d3350ffa08f921bb3d1ad.jpg" },
		  { name: "Ariana Grande", img: "https://media.tenor.com/1u94p6qR01gAAAAM/ariana-grande-eternal-sunshine.gif" },
		  { name: "Will", img: "https://i.pinimg.com/originals/88/80/73/8880736b5695844044e0e38c8063a1ff.gif" },
		  { name: "Carlos Oliveira", img: "https://i.pinimg.com/originals/32/0d/d1/320dd13031f1aba8a2d3d9b9837174f4.gif" },
		  { name: "Leon", img: "https://i.pinimg.com/736x/db/ef/fc/dbeffc6e915a929f7dbe908390f5af42.jpg" },
		  { name: "Spongebob", img: "https://i.pinimg.com/originals/4c/74/21/4c742132b3f7018e49ae1901a2ab3e68.gif" },
		  { name: "Patrick", img: "https://i.pinimg.com/736x/cc/45/b5/cc45b504e5bba418a3621d894a7693d6.jpg" },
		  { name: "Squiddi", img: "https://i.pinimg.com/originals/bb/9a/08/bb9a082dd1a1a8f49200b8f5e5392d23.gif" },
		  { name: "Alvin", img: "https://i.pinimg.com/1200x/42/b1/da/42b1da0676938e04cfcd2d16ae13e067.jpg" },
		  { name: "Poison Ivy", img: "https://i.pinimg.com/736x/72/f5/98/72f598d1ca69f3de7f38206b38d79066.jpg" },
          { name: "Sonic", img: "https://i.pinimg.com/1200x/4f/22/d2/4f22d2cd449a419b3859197438300dd2.jpg" },
		  { name: "Tails", img: "https://i.pinimg.com/736x/cb/f8/43/cbf84308cca2de1d9a776410716c6aee.jpg" },
		  { name: "Dr Eggman", img: "https://i.pinimg.com/736x/ca/6a/ec/ca6aec757d82fbd5498fc2f5322ffc2c.jpg" },
		  { name: "Scar", img: "https://i.pinimg.com/736x/4b/cc/0e/4bcc0e93c7086f7359c3e99fea022cd6.jpg" },
		  { name: "Malefica", img: "https://i.pinimg.com/736x/2f/83/9a/2f839a9b9b03a70f4b9feb812e8cf03a.jpg" },
		  { name: "Yzma", img: "https://i.pinimg.com/1200x/20/47/ae/2047ae86c81bd2b6e1ab00797a8584a8.jpg" },
		  { name: "Simba", img: "https://i.pinimg.com/736x/b1/90/89/b19089d874786ae283c4ba7f9ebed795.jpg" },
		  { name: "Aurora", img: "https://i.pinimg.com/736x/b1/75/fb/b175fbb3b147ea7a9f74ef16b7e4abd3.jpg" },
		  { name: "Kuzco", img: "https://i.pinimg.com/736x/75/cf/32/75cf32d90c87209bcf2c3e77be26117b.jpg" },
		  { name: "Kratos", img: "https://i.pinimg.com/1200x/c7/92/1e/c7921e20927ce5aea55d465a3685a055.jpg" },
		  { name: "Ben 10", img: "https://i.pinimg.com/736x/b3/c8/eb/b3c8ebedc4123fa33f6e72ff2deff109.jpg" },
          { name: "Gwen Tennyson", img: "https://i.pinimg.com/736x/f7/59/57/f75957bd5bad8195e2322e58de3f8119.jpg" }
        ];

        const TEAM_NAMES = [
          "Marmotte Urlanti", "Carpe Assassine", "Criceti Radioattivi", "Avvoltoi Volanti",
          "Tigri Selvaggi", "Orsi Polari", "Lupi Mannari", "Serpenti A Sonagli"
        ];

        const App = () => {
          const [user, setUser] = useState(null);
          const [nickname, setNickname] = useState('');
          const [currentView, setCurrentView] = useState('auth');
          const [lobbies, setLobbies] = useState([]);
          const [currentLobbyId, setCurrentLobbyId] = useState(null);
          const [lobbyData, setLobbyData] = useState(null);
          const [errorMsg, setErrorMsg] = useState('');

          // AUTH SETUP
          useEffect(() => {
            const initAuth = async () => {
              if (!auth) return;
              try {
                 await signInAnonymously(auth);
              } catch (e) {
                 console.error("Errore Autenticazione:", e);
              }
            };
            
            initAuth();
            
            if (auth) {
                const unsubscribe = onAuthStateChanged(auth, setUser);
                return () => unsubscribe();
            }
          }, []);

          // FETCH LOBBIES E CLEANUP
          useEffect(() => {
            if (!user || !db) return;
            
            // Funzione di pulizia (best effort, eseguita dal client)
            const cleanupOldLobbies = async () => {
                const querySnapshot = await getDocs(collection(db, 'artifacts', appId, 'public', 'data', 'lobbies'));
                const now = Date.now();
                
                querySnapshot.docs.forEach(async (docSnap) => {
                    const data = docSnap.data();
                    // Controlla se la lobby è in attesa e il timestamp è più vecchio di 10 minuti
                    if (data.status === 'waiting' && data.timestamp) {
                        const docTime = data.timestamp.toMillis();
                        if (docTime < (now - TEN_MINUTES_MS)) {
                            try {
                                await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', docSnap.id));
                                console.log(`Lobby ${docSnap.id} eliminata per inattività.`);
                            } catch(e) {
                                console.error("Errore eliminazione lobby inattiva:", e);
                            }
                        }
                    }
                });
            };

            // Esegue la pulizia al caricamento del BrowserScreen
            cleanupOldLobbies();

            const q = collection(db, 'artifacts', appId, 'public', 'data', 'lobbies');
            const unsubscribe = onSnapshot(q, (snapshot) => {
              const now = Date.now();
              
              const activeLobbies = snapshot.docs
                .map(d => ({ id: d.id, ...d.data() }))
                .filter(l => {
                     // 1. Deve essere in stato di attesa
                     if (l.status !== 'waiting') return false;
                     // 2. Deve avere un timestamp
                     if (!l.timestamp) return false;
                     
                     // 3. Deve essere stata creata meno di 10 minuti fa (lobby attiva)
                     return l.timestamp.toMillis() > (now - TEN_MINUTES_MS);
                });

              activeLobbies.sort((a, b) => b.timestamp.toMillis() - a.timestamp.toMillis());
              setLobbies(activeLobbies);
            }, (error) => {
                console.error("Errore fetch lobbies:", error);
                setErrorMsg("Errore di connessione al database. Controlla le regole Firestore.");
            });
            return () => unsubscribe();
          }, [user]);

          // SYNC LOBBY
          useEffect(() => {
            if (!user || !currentLobbyId || !db) return;
            const unsub = onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', currentLobbyId), (docSnap) => {
              if (docSnap.exists()) {
                const data = docSnap.data();
                setLobbyData(data);
                if (data.status === 'playing') setCurrentView('game');
              } else {
                setLobbyData(null);
                setCurrentLobbyId(null);
                setCurrentView('browser');
              }
            });
            return () => unsub();
          }, [currentLobbyId, user]);

          const createLobby = async (config) => {
            if (!user || !db) return;
            const code = Math.floor(1000 + Math.random() * 9000).toString();
            const newLobbyRef = doc(collection(db, 'artifacts', appId, 'public', 'data', 'lobbies'));
            
            const initialData = {
              hostId: user.uid,
              hostName: nickname,
              code: code,
              status: 'waiting',
              config: {
                ...config,
                redemption: config.redemption || { enabled: false, count: 0, episodes: [] }
              }, 
              currentSeasonIndex: 0,
              seasonWinners: [],
              rankings: [], 
              players: [{
                uid: user.uid,
                name: nickname,
                character: null,
                isBot: false,
                status: 'active',
                team: null,
                relationships: {},
                alliances: [],
                diceRoll: null,
                immunityWins: 0,
                totalVotesReceived: 0 // New field
              }],
              round: 0,
              phase: 'setup',
              logs: [`Lobby creata da ${nickname}. Codice: ${code}`],
              chat: [], 
              votes: {},
              readyPlayers: [], 
              immunity: [],
              losingTeam: null,
              ceremonyData: null,
              challengeData: null, 
              finalData: null, 
              redemptionData: null,
              idolData: null,
              timestamp: serverTimestamp()
            };

            await setDoc(newLobbyRef, initialData);
            setCurrentLobbyId(newLobbyRef.id);
            setCurrentView('lobby');
          };

          const joinLobby = async (lobbyId) => {
            if (!user || !db) return;
            const lobbyRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId);
            const snap = await getDoc(lobbyRef);
            if (!snap.exists()) return;
            const data = snap.data();
            
            if (data.players.length >= data.config.maxPlayers) return setErrorMsg("Lobby piena.");

            await updateDoc(lobbyRef, {
              players: arrayUnion({
                uid: user.uid,
                name: nickname,
                character: null,
                isBot: false,
                status: 'active',
                team: null,
                relationships: {},
                alliances: [],
                diceRoll: null,
                immunityWins: 0,
                totalVotesReceived: 0 // New field
              })
            });
            setCurrentLobbyId(lobbyId);
            setCurrentView('lobby');
          };

          if (!app) {
              return (
                  <div className="flex items-center justify-center h-screen bg-slate-900 text-white p-8 text-center">
                      <div>
                          <h1 className="text-3xl font-bold text-red-500 mb-4">Caricamento Firebase...</h1>
                      </div>
                  </div>
              );
          }

          return (
            <div className="min-h-screen bg-slate-900 text-slate-100 font-sans">
              {currentView === 'auth' && (
                <AuthScreen nickname={nickname} setNickname={setNickname} onEnter={() => setCurrentView('browser')} />
              )}
              {currentView === 'browser' && (
                <BrowserScreen 
                  user={user} nickname={nickname} lobbies={lobbies} 
                  onCreate={createLobby} onJoin={joinLobby} errorMsg={errorMsg}
                />
              )}
              {currentView === 'lobby' && lobbyData && (
                <LobbyRoom 
                  lobby={lobbyData} user={user} lobbyId={currentLobbyId} 
                  onLeave={() => { setCurrentLobbyId(null); setCurrentView('browser'); }} 
                />
              )}
              {currentView === 'game' && lobbyData && (
                <GameRoom 
                  lobby={lobbyData} user={user} lobbyId={currentLobbyId} 
                  onLeave={() => { setCurrentLobbyId(null); setCurrentView('browser'); }}
                />
              )}
            </div>
          );
        };

        // --- SCREENS ---

        const AuthScreen = ({ nickname, setNickname, onEnter }) => (
          <div className="flex flex-col items-center justify-center min-h-screen bg-[url('https://i.pinimg.com/originals/2b/96/96/2b969635546059637841555541578508.jpg')] bg-cover bg-center">
            <div className="bg-slate-900/90 p-8 rounded-2xl shadow-2xl backdrop-blur-sm max-w-md w-full text-center border-2 border-yellow-500">
              <h1 className="text-5xl font-black text-yellow-400 mb-2 drop-shadow-lg" style={{ WebkitTextStroke: '2px black' }}>TOTAL DRAMA</h1>
              <h2 className="text-2xl font-bold text-white mb-6 uppercase tracking-widest">Online Survivor</h2>
              <input
                type="text"
                placeholder="Il tuo Nickname"
                className="w-full bg-slate-800 border-2 border-slate-600 rounded-xl p-4 text-white text-center text-xl font-bold mb-4 focus:border-yellow-500 outline-none"
                value={nickname}
                onChange={e => setNickname(e.target.value)}
                maxLength={15}
              />
              <button
                onClick={onEnter}
                disabled={nickname.length < 2}
                className="w-full bg-yellow-500 hover:bg-yellow-400 text-black font-black py-4 rounded-xl text-xl uppercase transition shadow-lg disabled:opacity-50 transform hover:scale-105"
              >
                Entra nel Reality
              </button>
            </div>
          </div>
        );

        const BrowserScreen = ({ user, nickname, lobbies, onCreate, onJoin, errorMsg }) => {
          const [showConfig, setShowConfig] = useState(false);
          // Default mergeSize a 11 (metà di 22)
          const [config, setConfig] = useState({ 
              maxPlayers: 22, 
              numTeams: 2, 
              numSeasons: 1, 
              mergeSize: 11,
              redemption: { enabled: false, count: 1, episodes: "" } 
          });
          const [joinCode, setJoinCode] = useState('');

          return (
            <div className="max-w-4xl mx-auto p-4 py-8">
              {!showConfig ? (
                <>
                  <div className="flex justify-between items-center mb-8 bg-slate-800 p-6 rounded-2xl border border-slate-700">
                     <div>
                        <h2 className="text-3xl font-black text-yellow-400">LOBBY BROWSER</h2>
                        <p className="text-slate-400">Giocatore: <span className="text-white font-bold">{nickname}</span></p>
                     </div>
                     <button onClick={() => setShowConfig(true)} className="bg-green-600 hover:bg-green-500 text-white px-6 py-3 rounded-xl font-bold flex items-center gap-2 shadow-lg transition transform hover:scale-105">
                       <UserPlus size={20} /> CREA SHOW
                     </button>
                  </div>

                  <div className="bg-slate-800 rounded-2xl p-6 shadow-xl border border-slate-700 mb-8">
                      <h3 className="text-xl font-bold mb-4 flex items-center gap-2"><Play size={20} className="text-purple-400"/> Unisciti con Codice</h3>
                      <div className="flex gap-2">
                        <input value={joinCode} onChange={e => setJoinCode(e.target.value)} maxLength={4} placeholder="0000" className="bg-slate-900 rounded-lg px-4 py-2 w-32 text-center text-xl tracking-widest font-mono text-white" />
                        <button onClick={() => {
                           const lobby = lobbies.find(l => l.code === joinCode);
                           if(lobby) onJoin(lobby.id);
                        }} className="bg-purple-600 px-6 py-2 rounded-lg font-bold hover:bg-purple-500 text-white">VAI</button>
                      </div>
                      {errorMsg && <p className="text-red-400 mt-2 font-bold">{errorMsg}</p>}
                   </div>

                   <div className="grid gap-4">
                     {lobbies.length === 0 ? (
                       <div className="text-center py-12 text-slate-500 italic bg-slate-800/50 rounded-xl">Nessuna partita in corso.</div>
                     ) : (
                       lobbies.map(l => (
                         <div key={l.id} className="bg-slate-800 p-4 rounded-xl flex justify-between items-center hover:bg-slate-700/50 border border-slate-700 transition">
                           <div>
                             <span className="font-bold text-lg text-white">{l.hostName}'s Show</span>
                             <div className="flex gap-2 mt-1">
                                <span className="text-xs bg-yellow-900 text-yellow-200 px-2 py-0.5 rounded font-mono">Stagioni: {l.config.numSeasons}</span>
                                <span className="text-xs bg-blue-900 text-blue-200 px-2 py-0.5 rounded font-mono">Max: {l.config.maxPlayers}</span>
                                <span className="text-xs bg-red-900 text-red-200 px-2 py-0.5 rounded font-mono">Merge: {l.config.mergeSize || Math.floor(l.config.maxPlayers/2)}</span>
                             </div>
                           </div>
                           <div className="flex items-center gap-4">
                              <span className="text-slate-400 font-mono bg-slate-900 px-2 py-1 rounded">CODE: {l.code}</span>
                              <button onClick={() => onJoin(l.id)} className="bg-blue-600 hover:bg-blue-500 px-4 py-2 rounded-lg font-bold text-sm text-white">ENTRA</button>
                           </div>
                         </div>
                       ))
                     )}
                   </div>
                </>
              ) : (
                <div className="bg-slate-800 p-8 rounded-2xl shadow-2xl border-2 border-yellow-500 max-w-lg mx-auto">
                  <h2 className="text-3xl font-black text-center mb-6 text-white">CONFIGURA SHOW</h2>
                  
                  <div className="space-y-6">
                    <div>
                      {/* MODIFICATO IL LIMITE MAX A 62 */}
                      <label className="block text-slate-400 font-bold mb-2">Concorrenti (8 - 62)</label>
                      <div className="flex items-center gap-4">
                        <input type="range" min="8" max="62" value={config.maxPlayers} onChange={e => {
                            const newVal = parseInt(e.target.value);
                            setConfig({
                                ...config, 
                                maxPlayers: newVal,
                                mergeSize: Math.min(config.mergeSize, newVal - 1)
                            });
                        }} className="flex-1 accent-yellow-500" />
                        <span className="text-2xl font-bold w-12 text-center">{config.maxPlayers}</span>
                      </div>
                    </div>

                    <div>
                      <label className="block text-slate-400 font-bold mb-2">Squadre (2 - 8)</label>
                      <div className="flex items-center gap-4">
                        <input type="range" min="2" max="8" value={config.numTeams} onChange={e => setConfig({...config, numTeams: parseInt(e.target.value)})} className="flex-1 accent-blue-500" />
                        <span className="text-2xl font-bold w-12 text-center">{config.numTeams}</span>
                      </div>
                    </div>

                    <div>
                      <label className="block text-slate-400 font-bold mb-2">Merge quando rimangono:</label>
                      <div className="flex items-center gap-4">
                        <input 
                            type="range" 
                            min="3" 
                            max={Math.max(3, config.maxPlayers - 2)} 
                            value={config.mergeSize} 
                            onChange={e => setConfig({...config, mergeSize: parseInt(e.target.value)})} 
                            className="flex-1 accent-red-500" 
                        />
                        <span className="text-2xl font-bold w-12 text-center">{config.mergeSize}</span>
                      </div>
                    </div>

                    <div>
                      <label className="block text-slate-400 font-bold mb-2">Stagioni (1 - 3)</label>
                      <div className="flex gap-2">
                        {[1, 2, 3].map(n => (
                          <button 
                            key={n} 
                            onClick={() => setConfig({...config, numSeasons: n})}
                            className={`flex-1 py-3 rounded-xl font-bold border-2 ${config.numSeasons === n ? 'bg-yellow-500 text-black border-yellow-500' : 'bg-slate-900 border-slate-700 text-slate-400'}`}
                          >
                            {n}
                          </button>
                        ))}
                      </div>
                    </div>

                    {/* SEZIONE REDEMPTION */}
                    <div className="bg-slate-900/50 p-4 rounded-xl border border-slate-700">
                        <div className="flex justify-between items-center mb-4">
                            <label className="text-white font-bold flex items-center gap-2">
                                <Undo2 className="text-orange-400"/> Redemption?
                            </label>
                            <input 
                                type="checkbox" 
                                checked={config.redemption.enabled} 
                                onChange={e => setConfig({...config, redemption: { ...config.redemption, enabled: e.target.checked }})}
                                className="w-6 h-6 accent-orange-500"
                            />
                        </div>
                        
                        {config.redemption.enabled && (
                            <div className="space-y-4 animate-in fade-in">
                                <div>
                                    <label className="block text-slate-400 text-sm mb-1">Quanti Rientri (1-3)?</label>
                                    <input 
                                        type="number" 
                                        min="1" 
                                        max="3" 
                                        value={config.redemption.count}
                                        onChange={e => setConfig({...config, redemption: { ...config.redemption, count: parseInt(e.target.value) }})}
                                        className="w-full bg-slate-800 rounded px-2 py-1 text-white"
                                    />
                                </div>
                                <div>
                                    <label className="block text-slate-400 text-sm mb-1">In quali episodi? (es. 5, 10)</label>
                                    <input 
                                        type="text" 
                                        placeholder="Es. 5, 8"
                                        value={config.redemption.episodes}
                                        onChange={e => setConfig({...config, redemption: { ...config.redemption, episodes: e.target.value }})}
                                        className="w-full bg-slate-800 rounded px-2 py-1 text-white"
                                    />
                                    <p className="text-xs text-slate-500 mt-1">Separa i numeri degli episodi con la virgola.</p>
                                </div>
                            </div>
                        )}
                    </div>

                    <div className="flex gap-4 pt-4">
                      <button onClick={() => setShowConfig(false)} className="flex-1 bg-slate-700 py-3 rounded-xl font-bold text-white">Annulla</button>
                      <button onClick={() => {
                          // Parse episodes string to array
                          const parsedEpisodes = config.redemption.enabled 
                              ? config.redemption.episodes.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n))
                              : [];
                          
                          onCreate({
                              ...config,
                              redemption: {
                                  ...config.redemption,
                                  episodes: parsedEpisodes
                              }
                          });
                      }} className="flex-1 bg-green-600 hover:bg-green-500 py-3 rounded-xl font-bold text-white shadow-lg">CREA LOBBY</button>
                    </div>
                  </div>
                </div>
              )}
            </div>
          );
        };

        const LobbyRoom = ({ lobby, user, lobbyId, onLeave }) => {
          const isHost = lobby.hostId === user.uid;

          const selectCharacter = async (char) => {
            if (lobby.players.some(p => p.character?.name === char.name)) return;
            const updatedPlayers = lobby.players.map(p => p.uid === user.uid ? { ...p, character: char } : p);
            await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), { players: updatedPlayers });
          };

          const startSeason = async () => {
            let currentPlayers = [...lobby.players];
            const usedNames = new Set(currentPlayers.map(p => p.character?.name).filter(Boolean));
            
            currentPlayers = currentPlayers.map(p => {
              if (!p.character) {
                const available = ROSTER.filter(r => !usedNames.has(r.name));
                const random = available[Math.floor(Math.random() * available.length)];
                usedNames.add(random.name);
                return { ...p, character: random };
              }
              return p;
            });

            while (currentPlayers.length < lobby.config.maxPlayers) {
              const available = ROSTER.filter(r => !usedNames.has(r.name));
              if (available.length === 0) break;
              const randomChar = available[Math.floor(Math.random() * available.length)];
              usedNames.add(randomChar.name);
              
              const botId = `bot_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
              currentPlayers.push({
                uid: botId,
                name: randomChar.name,
                character: randomChar,
                isBot: true,
                status: 'active',
                team: null,
                relationships: {},
                alliances: [],
                diceRoll: null,
                immunityWins: 0,
                totalVotesReceived: 0 // New field
              });
            }

            const numTeams = lobby.config.numTeams;
            for (let i = currentPlayers.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [currentPlayers[i], currentPlayers[j]] = [currentPlayers[j], currentPlayers[i]];
            }
            currentPlayers = currentPlayers.map((p, idx) => ({
              ...p,
              team: TEAM_NAMES[idx % numTeams]
            }));

            // --- IDOL SETUP ---
            const totalCrates = currentPlayers.length;
            const luckyIndex = Math.floor(Math.random() * totalCrates);
            // We create simple objects for crates. Content is determined by index vs luckyIndex to avoid cheating by inspecting client data too easily (though serverless implies transparency).
            // Better: store luckyIndex in idolData.
            const initialCrates = Array.from({length: totalCrates}, (_, i) => ({ id: i, owner: null }));

            await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
              players: currentPlayers,
              status: 'playing',
              phase: 'idol_hunt', // NEW PHASE
              idolData: {
                  active: true,
                  luckyIndex: luckyIndex,
                  crates: initialCrates,
                  stage: 'selection', // selection -> reveal
                  holder: null
              },
              round: 0,
              logs: arrayUnion(`--- CACCIA ALL'IDOLO DELL'IMMUNITÀ ---`)
            });
          };

          return (
            <div className="flex flex-col h-screen overflow-hidden">
              <header className="bg-slate-800 p-4 border-b border-slate-700 flex justify-between items-center z-10">
                <div>
                  <h2 className="text-xl font-bold text-white">Lobby: {lobby.hostName}</h2>
                  <p className="text-slate-400 text-sm">Codice: {lobby.code} | Max: {lobby.config.maxPlayers} | Teams: {lobby.config.numTeams}</p>
                </div>
                <button onClick={onLeave} className="text-red-400 font-bold text-sm">Esci</button>
              </header>

              <div className="flex-1 flex flex-col md:flex-row overflow-hidden">
                <div className="w-full md:w-64 bg-slate-900 p-4 overflow-y-auto border-r border-slate-800">
                  <h3 className="font-bold text-slate-300 mb-2 uppercase text-xs">Giocatori ({lobby.players.length}/{lobby.config.maxPlayers})</h3>
                  <div className="space-y-2">
                    {lobby.players.map(p => (
                      <div key={p.uid} className="bg-slate-800 p-2 rounded flex items-center gap-2">
                        <div className="w-8 h-8 rounded-full bg-slate-700 overflow-hidden flex-shrink-0">
                           {p.character ? <img src={p.character.img} className="w-full h-full object-cover" /> : <div className="animate-pulse bg-slate-600 w-full h-full"/>}
                        </div>
                        <div className="truncate text-sm font-bold">{p.name}</div>
                      </div>
                    ))}
                  </div>
                  {isHost && (
                    <button onClick={startSeason} className="w-full mt-4 bg-green-600 hover:bg-green-500 text-white py-3 rounded-xl font-bold shadow-lg">
                      INIZIA STAGIONE 1
                    </button>
                  )}
                </div>

                <div className="flex-1 p-4 overflow-y-auto bg-slate-900">
                   <h3 className="text-xl font-bold mb-4 text-center text-yellow-400">SCEGLI IL TUO PERSONAGGIO</h3>
                   <div className="grid grid-cols-4 sm:grid-cols-5 md:grid-cols-6 lg:grid-cols-8 gap-2">
                     {ROSTER.map(char => {
                       const takenBy = lobby.players.find(p => p.character?.name === char.name);
                       const isMe = takenBy?.uid === user.uid;
                       return (
                         <button 
                           key={char.name}
                           onClick={() => selectCharacter(char)}
                           disabled={!!takenBy}
                           className={`relative rounded-lg overflow-hidden border-2 aspect-[3/4] transition ${isMe ? 'border-green-500 ring-2 ring-green-500' : takenBy ? 'border-red-900 opacity-40' : 'border-slate-700 hover:border-yellow-500'}`}
                         >
                           <img src={char.img} alt={char.name} className="w-full h-full object-cover" />
                           {isMe && <div className="absolute inset-0 border-4 border-green-500"></div>}
                         </button>
                       )
                     })}
                   </div>
                </div>
              </div>
            </div>
          );
        };

        // --- GAME LOGIC ---

        const GameRoom = ({ lobby, user, lobbyId, onLeave }) => {
          const isHost = lobby.hostId === user.uid;
          const myPlayer = lobby.players.find(p => p.uid === user.uid);
          const activePlayers = lobby.players.filter(p => p.status === 'active');
          const currentSeason = SEASON_CONFIG[lobby.currentSeasonIndex] || SEASON_CONFIG[0];
          const isMerge = activePlayers.length <= (lobby.config.mergeSize || (lobby.config.maxPlayers / 2)); 

          const [hasActed, setHasActed] = useState(false);
          const [chatInput, setChatInput] = useState("");
          const chatRef = useRef(null);
          
          const [nextSeasonConfig, setNextSeasonConfig] = useState(null); 
          const [selectedRedemptionCandidates, setSelectedRedemptionCandidates] = useState([]);

          const [selectedPlayer, setSelectedPlayer] = useState(null);

          useEffect(() => {
            setHasActed(false);
            setSelectedPlayer(null);
          }, [lobby.phase, lobby.round]);

          useEffect(() => {
            if (chatRef.current) chatRef.current.scrollTop = chatRef.current.scrollHeight;
          }, [lobby.chat]);

          // --- IDOL HUNT BOT LOGIC ---
          useEffect(() => {
              if (!isHost || lobby.phase !== 'idol_hunt' || !lobby.idolData || lobby.idolData.stage !== 'selection') return;

              const bots = lobby.players.filter(p => p.isBot);
              const unchosenBots = bots.filter(b => !lobby.idolData.crates.some(c => c.owner === b.uid));
              
              if (unchosenBots.length > 0) {
                  const timer = setTimeout(async () => {
                      const availableCrates = lobby.idolData.crates.filter(c => c.owner === null);
                      if (availableCrates.length > 0 && unchosenBots.length > 0) {
                          const botToAct = unchosenBots[0];
                          const randomCrate = availableCrates[Math.floor(Math.random() * availableCrates.length)];
                          
                          const newCrates = lobby.idolData.crates.map(c => 
                              c.id === randomCrate.id ? { ...c, owner: botToAct.uid } : c
                          );

                          // Check if everyone has chosen
                          const allTaken = newCrates.every(c => c.owner !== null);
                          let updates = { [`idolData.crates`]: newCrates };
                          
                          if (allTaken) {
                              updates[`idolData.stage`] = 'reveal';
                              // Assign holder internally
                              const winnerUid = newCrates.find(c => c.id === lobby.idolData.luckyIndex)?.owner;
                              updates[`idolData.holder`] = winnerUid;
                              updates[`logs`] = arrayUnion("Tutte le casse sono state assegnate! Apertura in corso...");
                          }

                          await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), updates);
                      }
                  }, 500); // Fast selection
                  return () => clearTimeout(timer);
              }
          }, [lobby.idolData, isHost]);


          // SEQUENTIAL DICE ANIMATION (HOST FOR BOTS ONLY)
          useEffect(() => {
            if (!isHost || lobby.phase !== 'challenge' || !lobby.challengeData || lobby.challengeData.stage !== 'rolling') return;

            const { rollingIndex, players: rollPlayers, rolls } = lobby.challengeData;
            
            // --- CALCOLO VINCITORI A FINE GIRI ---
            if (rollingIndex >= rollPlayers.length) {
                 
                 // --- LOGICA SUDDEN DEATH (ELIMINAZIONE DIRETTA) ---
                 if (lobby.challengeData.type === 'sudden_death') {
                    let minRoll = 11;
                    let losers = [];
                    Object.entries(rolls).forEach(([uid, r]) => {
                        if (r < minRoll) { minRoll = r; losers = [uid]; }
                        else if (r === minRoll) { losers.push(uid); }
                    });

                    if (losers.length > 1) {
                         // Tie for loser
                         const loserNames = losers.map(w => lobby.players.find(p => p.uid === w)?.name).join(", ");
                         updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
                             [`challengeData.players`]: losers,
                             [`challengeData.rollingIndex`]: 0,
                             [`challengeData.rolls`]: {},
                             logs: arrayUnion(`PAREGGIO PER L'ELIMINAZIONE (${minRoll})! Spareggio tra: ${loserNames}`)
                         });
                    } else {
                         // Eliminate loser
                         const victimId = losers[0];
                         const victim = lobby.players.find(p => p.uid === victimId);
                         
                         const updatedPlayers = lobby.players.map(p => p.uid === victimId ? { ...p, status: 'eliminated' } : p);
                         
                         const rankingEntry = { 
                              name: victim.name, 
                              team: victim.team || "Merge", 
                              round: lobby.round, 
                              season: currentSeason.name,
                              immunities: victim.immunityWins || 0,
                              votes: victim.totalVotesReceived || 0
                         };

                         // Verifica Redemption
                         const nextRound = lobby.round + 1;
                         const redemptionConfig = lobby.config.redemption;
                         let isRedemptionEpisode = false;
                         if (redemptionConfig && redemptionConfig.enabled && redemptionConfig.episodes) {
                              if (Array.isArray(redemptionConfig.episodes)) {
                                   isRedemptionEpisode = redemptionConfig.episodes.includes(nextRound);
                              }
                         }

                         let updates = {
                             players: updatedPlayers,
                             rankings: arrayUnion(rankingEntry),
                             logs: arrayUnion(`${victim.name} ha fatto il punteggio più basso (${minRoll}) ed è ELIMINATO DIRETTAMENTE!`)
                         };

                         if (isRedemptionEpisode) {
                              updates = {
                                  ...updates,
                                  phase: 'redemption',
                                  redemptionData: { active: true, stage: 'selection', candidates: [], rolls: {} },
                                  round: nextRound,
                                  votes: {},
                                  immunity: [],
                                  diceRoll: null,
                                  losingTeam: null,
                                  ceremonyData: null,
                                  challengeData: null,
                                  logs: arrayUnion(`${victim.name} è stato eliminato!`, `--- EPISODIO SPECIALE: REDEMPTION! ---`)
                              };
                         } else {
                              updates = {
                                  ...updates,
                                  phase: 'episode_start', // Torna all'inizio episodio
                                  round: nextRound,
                                  votes: {},
                                  immunity: [],
                                  diceRoll: null,
                                  losingTeam: null,
                                  ceremonyData: null,
                                  challengeData: null
                              };
                         }

                         updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), updates);
                    }
                    return;
                 }

                 // --- LOGICA SFIDA A SQUADRE (NEW) ---
                 if (lobby.challengeData.type === 'team') {
                     const teamScores = { A: 0, B: 0 };
                     const teams = lobby.challengeData.teams;

                     Object.entries(rolls).forEach(([uid, r]) => {
                         const team = teams[uid];
                         if (team) teamScores[team] += r;
                     });

                     let winnerTeam = null;
                     if (teamScores.A > teamScores.B) winnerTeam = 'A';
                     else if (teamScores.B > teamScores.A) winnerTeam = 'B';
                     else winnerTeam = Math.random() > 0.5 ? 'A' : 'B'; // Coin flip on total tie (rare but possible)

                     const immunePlayers = Object.keys(teams).filter(uid => teams[uid] === winnerTeam);
                     
                     updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
                         [`challengeData.stage`]: 'finished',
                         [`challengeData.winner`]: immunePlayers, // Array di vincitori
                         immunity: immunePlayers,
                         losingTeam: "MERGE",
                         readyPlayers: [], 
                         phase: 'social',
                         logs: arrayUnion(`La Squadra ${winnerTeam === 'A' ? 'ROSSA' : 'BLU'} vince la sfida a squadre! (${teamScores[winnerTeam]} vs ${teamScores[winnerTeam === 'A' ? 'B' : 'A']})`)
                     });
                     return;
                 }


                 // --- LOGICA INDIVIDUALE STANDARD ---
                 let maxRoll = -1;
                 let winners = [];
                 Object.entries(rolls).forEach(([uid, r]) => {
                     if (r > maxRoll) { maxRoll = r; winners = [uid]; }
                     else if (r === maxRoll) { winners.push(uid); }
                 });

                 // FIX: LOGICA PAREGGIO (SPAREGGIO)
                 if (winners.length > 1) {
                     const winnerNames = winners.map(w => lobby.players.find(p => p.uid === w)?.name).join(", ");
                     
                     updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
                         [`challengeData.players`]: winners, // Solo loro rilanciano
                         [`challengeData.rollingIndex`]: 0,
                         [`challengeData.rolls`]: {}, // Reset dei tiri
                         logs: arrayUnion(`PAREGGIO (${maxRoll})! Spareggio per l'immunità tra: ${winnerNames}`)
                     });
                     return;
                 }

                 // AGGIORNAMENTO IMMUNITÀ (VINCITORE SINGOLO)
                 const winnerId = winners[0];
                 const winnerName = lobby.players.find(p => p.uid === winnerId)?.name;

                 const updatedPlayers = lobby.players.map(p => {
                     if (p.uid === winnerId) {
                         return { ...p, immunityWins: (p.immunityWins || 0) + 1 };
                     }
                     return p;
                 });
                 
                 updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
                     players: updatedPlayers,
                     [`challengeData.stage`]: 'finished',
                     [`challengeData.winner`]: winners,
                     immunity: winners,
                     losingTeam: "MERGE",
                     readyPlayers: [], // Reset ready players for social
                     phase: 'social',
                     logs: arrayUnion(`${winnerName} VINCE L'IMMUNITÀ con ${maxRoll}!`)
                 });
                 return;
            }

            const currentPlayerId = rollPlayers[rollingIndex];
            const playerObj = lobby.players.find(p => p.uid === currentPlayerId);

            if (playerObj?.isBot) {
                const timer = setTimeout(async () => {
                    const roll = Math.floor(Math.random() * 10) + 1;
                    const updatedRolls = { ...rolls, [currentPlayerId]: roll };
                    
                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
                        [`challengeData.rolls`]: updatedRolls,
                        [`challengeData.rollingIndex`]: rollingIndex + 1,
                        [`players`]: lobby.players.map(p => p.uid === currentPlayerId ? { ...p, diceRoll: roll } : p)
                    });
                }, 1500);
                return () => clearTimeout(timer);
            }
          }, [lobby.challengeData, isHost]);

          // --- BOT FINAL SHOWDOWN ROLLING ---
          useEffect(() => {
              if (!isHost || lobby.phase !== 'final_showdown' || !lobby.finalData) return;
              
              const { currentRolls } = lobby.finalData;
              const finalists = lobby.players.filter(p => p.status === 'active');
              
              finalists.forEach(p => {
                  if (p.isBot && (!currentRolls || !currentRolls[p.uid])) {
                       const timer = setTimeout(async () => {
                           const r = Math.floor(Math.random() * 10) + 1;
                           const updatedRolls = { ...(currentRolls || {}), [p.uid]: r };
                           await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
                               [`finalData.currentRolls`]: updatedRolls
                           });
                       }, 1000 + Math.random() * 1000); 
                       return () => clearTimeout(timer);
                  }
              });
          }, [lobby.finalData, isHost, lobby.phase]);

          // --- REDEMPTION ROLLING FOR BOTS ---
          useEffect(() => {
              if (!isHost || lobby.phase !== 'redemption' || !lobby.redemptionData || lobby.redemptionData.stage !== 'rolling') return;
              
              const candidates = lobby.redemptionData.candidates || [];
              const rolls = lobby.redemptionData.rolls || {};

              candidates.forEach(uid => {
                  const p = lobby.players.find(x => x.uid === uid);
                  if (p && p.isBot && !rolls[uid]) {
                      const timer = setTimeout(async () => {
                          const r = Math.floor(Math.random() * 10) + 1;
                          await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
                              [`redemptionData.rolls.${uid}`]: r
                          });
                      }, 1000 + Math.random() * 2000);
                      return () => clearTimeout(timer);
                  }
              });
          }, [lobby.redemptionData, isHost, lobby.phase]);


          const sendChat = async (e) => {
            e.preventDefault();
            if (!chatInput.trim()) return;
            const msg = {
                sender: myPlayer.name,
                text: chatInput.trim(),
                team: myPlayer.team || "Merge",
                ts: Date.now()
            };
            await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
                chat: arrayUnion(msg)
            });
            setChatInput("");
          };

          const handleUserRoll = async () => {
              const roll = Math.floor(Math.random() * 10) + 1;
              const { rollingIndex, rolls } = lobby.challengeData;
              const updatedRolls = { ...rolls, [user.uid]: roll };
              
              await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
                  [`challengeData.rolls`]: updatedRolls,
                  [`challengeData.rollingIndex`]: rollingIndex + 1,
                  [`players`]: lobby.players.map(p => p.uid === user.uid ? { ...p, diceRoll: roll } : p)
              });
          };

          const handleTieBreakRoll = async () => {
              const roll = Math.floor(Math.random() * 10) + 1;
              await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
                  [`ceremonyData.tieMatch.rolls.${user.uid}`]: roll
              });
          };

          const handleFinalRoll = async () => {
              if (lobby.phase !== 'final_showdown') return;
              const roll = Math.floor(Math.random() * 10) + 1;
              const currentRolls = lobby.finalData.currentRolls || {};
              
              await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
                  [`finalData.currentRolls.${user.uid}`]: roll
              });
          };

          const handleRedemptionRoll = async () => {
             const roll = Math.floor(Math.random() * 10) + 1;
             await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
                  [`redemptionData.rolls.${user.uid}`]: roll
             });
          };

          // --- IDOL HUNT: CLAIM CRATE ---
          const claimCrate = async (crateId) => {
              if (lobby.phase !== 'idol_hunt' || lobby.idolData.stage !== 'selection') return;
              if (lobby.idolData.crates.some(c => c.owner === user.uid)) return; // Already picked
              if (lobby.idolData.crates.find(c => c.id === crateId).owner !== null) return; // Taken

              const newCrates = lobby.idolData.crates.map(c => 
                   c.id === crateId ? { ...c, owner: user.uid } : c
              );

              // Check if everyone has chosen
              const allTaken = newCrates.every(c => c.owner !== null);
              
              let updates = { [`idolData.crates`]: newCrates };

              if (allTaken) {
                  updates[`idolData.stage`] = 'reveal';
                  const winnerUid = newCrates.find(c => c.id === lobby.idolData.luckyIndex)?.owner;
                  updates[`idolData.holder`] = winnerUid;
                  updates[`logs`] = arrayUnion("Tutte le casse sono state assegnate! Apertura in corso...");
              }

              await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), updates);
          };

          const toggleReady = async () => {
              await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
                  readyPlayers: arrayUnion(user.uid)
              });
          };


          const startNextSeason = async (newConfig) => {
            if (!isHost) return;
            
            const nextIndex = lobby.currentSeasonIndex + 1;
            const allParticipants = lobby.players; 
            
            // FILTER: Separate humans and bots
            const humans = allParticipants.filter(p => !p.isBot);
            const bots = allParticipants.filter(p => p.isBot);

            // Shuffle only bots
            bots.sort(() => Math.random() - 0.5);

            // LOGIC: Take all humans first, then fill with bots until returningCount
            let nextPlayersList = [...humans];
            const slotsForBots = Math.max(0, newConfig.returningCount - humans.length);
            
            if (slotsForBots > 0) {
                nextPlayersList = nextPlayersList.concat(bots.slice(0, slotsForBots));
            }
            
            let nextPlayers = nextPlayersList.map(p => ({
                uid: p.uid,
                name: p.name,
                character: p.character, 
                isBot: p.isBot,
                status: 'active', 
                team: null, 
                relationships: {}, 
                alliances: [], 
                diceRoll: null,
                immunityWins: 0,
                totalVotesReceived: p.totalVotesReceived || 0 // Preserve votes
            }));

            const numTeams = newConfig.numTeams;
            nextPlayers.sort(() => Math.random() - 0.5);
            nextPlayers = nextPlayers.map((p, idx) => ({
              ...p,
              team: TEAM_NAMES[idx % numTeams]
            }));

            await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
               currentSeasonIndex: nextIndex,
               players: nextPlayers,
               phase: 'episode_start',
               round: 1,
               config: {
                   ...lobby.config,
                   maxPlayers: newConfig.returningCount, 
                   numTeams: newConfig.numTeams,
                   mergeSize: newConfig.mergeSize
               },
               logs: arrayUnion(`--- INIZIO STAGIONE ${nextIndex + 1}: ${SEASON_CONFIG[nextIndex].name} ---`)
            });

            setNextSeasonConfig(null); 
          };

          const startRedemptionSelection = async () => {
             if (selectedRedemptionCandidates.length < 2) return;
             await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
                 [`redemptionData.candidates`]: selectedRedemptionCandidates,
                 [`redemptionData.stage`]: 'rolling',
                 logs: arrayUnion(`Inizia la sfida per il Rientro! ${selectedRedemptionCandidates.length} concorrenti si sfidano.`)
             });
          };

          const resolveRedemption = async () => {
             const { candidates, rolls } = lobby.redemptionData;
             // Verifica se tutti hanno lanciato
             const allRolled = candidates.every(c => rolls[c]);
             if (!allRolled) return;

             let maxRoll = -1;
             let potentialWinners = [];
             candidates.forEach(c => {
                 if(rolls[c] > maxRoll) { maxRoll = rolls[c]; potentialWinners = [c]; }
                 else if(rolls[c] === maxRoll) { potentialWinners.push(c); }
             });

             if (potentialWinners.length === 1) {
                 const winnerId = potentialWinners[0];
                 const winner = lobby.players.find(p => p.uid === winnerId);
                 
                 const activePlayers = lobby.players.filter(p => p.status === 'active');
                 let targetTeam = "Merge";
                 
                 // FIX: Controllo se ci sono ancora squadre attive basandomi sui giocatori attivi
                 // Se i giocatori hanno un team diverso da "Merge" o null, allora siamo ancora in fase a squadre
                 const activeTeamsList = [...new Set(activePlayers.map(p => p.team).filter(t => t && t !== "Merge"))];
                 
                 if (activeTeamsList.length > 0) {
                     const teamCounts = {};
                     activeTeamsList.forEach(t => teamCounts[t] = 0);
                     
                     activePlayers.forEach(p => { 
                         if(p.team && activeTeamsList.includes(p.team)) {
                             teamCounts[p.team] = (teamCounts[p.team] || 0) + 1;
                         }
                     });
                     
                     let minCount = 999;
                     // Trova il team con meno giocatori
                     Object.entries(teamCounts).forEach(([t, count]) => {
                         if (count < minCount) { minCount = count; targetTeam = t; }
                         else if (count === minCount && Math.random() > 0.5) { targetTeam = t; } 
                     });
                 }

                 const updatedPlayers = lobby.players.map(p => 
                     p.uid === winnerId ? { ...p, status: 'active', team: targetTeam, immunityWins: 0 } : p
                 );

                 await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
                    players: updatedPlayers,
                    phase: 'episode_start',
                    round: lobby.round, // Non aumenta il round, riprende l'episodio
                    redemptionData: null,
                    logs: arrayUnion(`${winner.name} VINCE IL RIENTRO e torna nel team ${targetTeam}!`)
                 });
                 setSelectedRedemptionCandidates([]);

             } else {
                 // Pareggio, reset rolls
                 await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
                    [`redemptionData.rolls`]: {},
                    logs: arrayUnion("Pareggio nel rientro! Si rilanciano i dadi.")
                 });
             }
          };


          const advanceGame = async () => {
            if (!isHost) return;

            let updates = {};
            let newLogs = [];

            // --- ADVANCE FROM IDOL HUNT TO EPISODE 1 ---
            if (lobby.phase === 'idol_hunt') {
                if (lobby.idolData.stage === 'reveal') {
                    updates = {
                        phase: 'episode_start',
                        round: 1,
                        logs: arrayUnion(`--- INIZIO STAGIONE 1: L'ISOLA ---`)
                    }
                }
            }

            else if (lobby.phase === 'episode_start') {
              const mergeSize = lobby.config.mergeSize || (lobby.config.maxPlayers / 2);
              
              if (activePlayers.length <= 2) {
                  updates = { 
                      phase: 'final_showdown', 
                      finalData: { p1Score: 0, p2Score: 0, round: 1, history: [], currentRolls: {} },
                      logs: arrayUnion(`--- GRAN FINALE! ---`) 
                  };
              } else {
                  updates = { phase: 'challenge', logs: arrayUnion(`--- SFIDA EPISODIO ${lobby.round} ---`) };
                  
                  if (isMerge) {
                      const rand = Math.random();
                      
                      if (rand < 0.06) {
                           // --- SUDDEN DEATH (6%) ---
                           const rollers = activePlayers.map(p => p.uid);
                           updates.challengeData = {
                               type: 'sudden_death',
                               players: rollers,
                               rollingIndex: 0,
                               rolls: {},
                               stage: 'rolling',
                               winner: null 
                           };
                           newLogs.push("Chris: COLPO DI SCENA! Sfida ad Eliminazione Diretta!");
                           newLogs.push("Chi fa il numero più basso TORNA A CASA. Niente votazioni.");
                      
                      } else if (rand < 0.14) { 
                          // --- TEAM CHALLENGE (8%) ---
                          const shuffled = [...activePlayers].sort(() => Math.random() - 0.5);
                          const mid = Math.ceil(shuffled.length / 2);
                          const teamA = shuffled.slice(0, mid).map(p => p.uid);
                          const teamB = shuffled.slice(mid).map(p => p.uid);
                          
                          const tempTeams = {};
                          teamA.forEach(uid => tempTeams[uid] = 'A');
                          teamB.forEach(uid => tempTeams[uid] = 'B');

                          updates.challengeData = {
                              type: 'team', 
                              teams: tempTeams,
                              players: [...teamA, ...teamB], 
                              rollingIndex: 0,
                              rolls: {},
                              stage: 'rolling',
                              winner: null
                          };
                          newLogs.push("Chris: Oggi sfida speciale! Vi dividerò in due squadre casuali.");
                          newLogs.push("La squadra che totalizza il punteggio più alto vince l'immunità!");

                      } else {
                          // --- STANDARD INDIVIDUAL ---
                          const rollers = activePlayers.map(p => p.uid);
                          updates.challengeData = {
                              type: 'individual',
                              players: rollers,
                              rollingIndex: 0,
                              rolls: {},
                              stage: 'rolling',
                              winner: null
                          };
                      }
                  } else {
                      // PRE-MERGE (Standard Teams)
                      
                      // --- 10% CHANCE TEAM SWAP (NEW) ---
                      if (Math.random() < 0.10) {
                          const teamsMap = {};
                          // Raggruppa i giocatori attivi per team
                          activePlayers.forEach(p => {
                              if (!teamsMap[p.team]) teamsMap[p.team] = [];
                              teamsMap[p.team].push(p);
                          });
                          
                          const teamNames = Object.keys(teamsMap);
                          if (teamNames.length >= 2) {
                              // Ordina team per dimensione (Decrescente)
                              teamNames.sort((a, b) => teamsMap[b].length - teamsMap[a].length);
                              
                              const bigTeam = teamNames[0];
                              const smallTeam = teamNames[teamNames.length - 1];
                              
                              // Esegui lo swap solo se il team grande ha più membri del piccolo
                              if (teamsMap[bigTeam].length > teamsMap[smallTeam].length) {
                                  const victim = teamsMap[bigTeam][Math.floor(Math.random() * teamsMap[bigTeam].length)];
                                  
                                  // Aggiorna la lista giocatori
                                  const updatedPlayers = lobby.players.map(p => 
                                      p.uid === victim.uid ? { ...p, team: smallTeam } : p
                                  );
                                  
                                  updates.players = updatedPlayers;
                                  newLogs.push(`COLPO DI SCENA! Chris: "${victim.name}, prendi le tue cose! Passi dai ${bigTeam} ai ${smallTeam}!"`);
                              }
                          }
                      }

                      const rollers = activePlayers.map(p => p.uid);
                      updates.challengeData = {
                         type: 'standard', // Pre-merge standard
                         players: rollers,
                      };
                  }
              }
            }
            
            else if (lobby.phase === 'challenge') {
              if (!isMerge) {
                 const teams = [...new Set(activePlayers.map(p => p.team))];
                 const winningTeam = teams[Math.floor(Math.random() * teams.length)];
                 const losingTeams = teams.filter(t => t !== winningTeam);
                 const losingTeam = losingTeams[0]; 

                 const immuneIds = lobby.players.filter(p => p.team === winningTeam && p.status === 'active').map(p => p.uid);
                 
                 newLogs.push(`IL TEAM ${winningTeam} VINCE!`);
                 newLogs.push(`Il team ${losingTeam} DEVE VOTARE.`);

                 updates = {
                    immunity: immuneIds,
                    losingTeam: losingTeam,
                    readyPlayers: [], // Reset per social
                    phase: 'social',
                    logs: arrayUnion(...newLogs)
                 };
              }
              // MERGE LOGIC IS HANDLED INSIDE useEffect (Rolling) -> Auto transitions
            }

            else if (lobby.phase === 'social') {
                const botVotes = calculateBotVotes(lobby, isMerge);
                updates = {
                    phase: 'voting',
                    votes: botVotes,
                    logs: arrayUnion("È TEMPO DI VOTARE!")
                };
            }

            else if (lobby.phase === 'voting') {
                const isDoubleElimination = isMerge && Math.random() < 0.05; // 5% chance ONLY IF MERGE
                const isOpenVote = Math.random() < 0.05; // 5% chance ALWAYS (Voti Palesi)
                
                const { safe, bottomTwo, eliminated, voteCounts, tie } = calculateCeremonyResults(lobby, lobby.votes, isMerge, isDoubleElimination);
                
                // --- UPDATE TOTAL VOTES RECEIVED ---
                const updatedPlayersWithVotes = lobby.players.map(p => {
                    const received = voteCounts[p.uid] || 0;
                    if (received > 0) {
                        return { ...p, totalVotesReceived: (p.totalVotesReceived || 0) + received };
                    }
                    return p;
                });
                
                if (isDoubleElimination) {
                   newLogs.push("!!! COLPO DI SCENA !!! Chris: 'Questa sera, per la prima volta, abbiamo una DOPPIA ELIMINAZIONE!'");
                }

                // Generazione mappa votanti se i voti sono palesi
                let votersMap = {};
                if (isOpenVote) {
                     newLogs.push("!!! COLPO DI SCENA !!! Chris: 'Stasera i voti sono PALESI! Niente segreti!'");
                     Object.entries(lobby.votes).forEach(([voterId, targetId]) => {
                        const voter = lobby.players.find(p => p.uid === voterId);
                        if(voter) {
                            if(!votersMap[targetId]) votersMap[targetId] = [];
                            votersMap[targetId].push(voter.name);
                        }
                     });
                }

                updates = { 
                    phase: 'ceremony', 
                    players: updatedPlayersWithVotes,
                    ceremonyData: { 
                        safe, bottomTwo, eliminated, revealedCount: 0, voteCounts,
                        isDoubleElimination: isDoubleElimination, // Nuovo campo
                        isOpenVote: isOpenVote, // NEW: Flag voti palesi
                        votersMap: votersMap,   // NEW: Mappa votanti
                        eliminatedSecond: (eliminated && eliminated.length > 1) ? eliminated[1] : null, // Secondo eliminato
                        tieMatch: tie ? { candidates: tie, rolls: {}, stage: 'rolling' } : null
                    },
                    logs: arrayUnion("--- CERIMONIA DI ELIMINAZIONE ---", ...newLogs)
                };
            }

            else if (lobby.phase === 'ceremony') {
              const data = lobby.ceremonyData;
              
              if (data.tieMatch) {
                  const { candidates, rolls } = data.tieMatch;
                  const allRolled = (candidates || []).every(uid => rolls[uid]);
                  if (allRolled) {
                     let minRoll = 11;
                     let losers = [];
                     (candidates || []).forEach(uid => {
                         if (rolls[uid] < minRoll) { minRoll = rolls[uid]; losers = [uid]; }
                         else if (rolls[uid] === minRoll) { losers.push(uid); }
                     });

                     if (losers.length === 1) {
                         const elimId = losers[0];
                         const safe = data.safe.concat((candidates || []).filter(c => c !== elimId));
                         
                         updates = {
                             [`ceremonyData.eliminated`]: elimId,
                             [`ceremonyData.tieMatch`]: null,
                             [`ceremonyData.safe`]: safe,
                             [`ceremonyData.revealedCount`]: data.revealedCount 
                         };
                     } else {
                         newLogs.push("ANCORA PAREGGIO! Si rilancia.");
                         updates = {
                             [`ceremonyData.tieMatch.rolls`]: {},
                             logs: arrayUnion(...newLogs)
                         };
                     }
                  } else {
                      (candidates || []).forEach(uid => {
                          if (!rolls[uid]) {
                              const p = lobby.players.find(x => x.uid === uid);
                              if (p && p.isBot) {
                                  const r = Math.floor(Math.random() * 10) + 1;
                                  updates[`ceremonyData.tieMatch.rolls.${uid}`] = r;
                              }
                          }
                      });
                  }
              } 
              else if (data.revealedCount < data.safe.length) {
                 updates = { [`ceremonyData.revealedCount`]: data.revealedCount + 1 };
              } 
              else if (!data.finalReveal) {
                  updates = { [`ceremonyData.finalReveal`]: true };
              } 
              else {
                  // FINE CERIMONIA

                  let victimsIds = Array.isArray(data.eliminated) ? [...data.eliminated] : [data.eliminated].filter(Boolean);
                  const isDouble = data.isDoubleElimination;
                  
                  // --- IDOL CHECK (First Victim) ---
                  let firstVictim = victimsIds[0];
                  if (firstVictim && lobby.idolData && lobby.idolData.holder === firstVictim && lobby.idolData.active) {
                      newLogs.push(`COLPO DI SCENA! ${lobby.players.find(p => p.uid === firstVictim).name} usa l'Idolo dell'Immunità!`);
                      updates[`idolData.active`] = false; 
                      updates[`idolData.holder`] = null;

                      // Sostituisce il primo eliminato con il prossimo più votato (il terzo se non c'è doppio, o il secondo del bottomTwo se non è doppio, oppure il terzo in generale se doppio)
                      // Poiché calculateCeremonyResults ritorna 'eliminated' come array ordinato per voti (dal più alto), il secondo elemento è il 'runner up'
                      const runnerUpId = data.bottomTwo.find(id => id !== firstVictim);
                      
                      if (runnerUpId) {
                         firstVictim = runnerUpId;
                         newLogs.push(`Il secondo più votato, ${lobby.players.find(p => p.uid === firstVictim).name}, viene eliminato al suo posto!`);
                      } else {
                          // Solo se c'è un voto unanime non gestito dal tie, annulliamo l'eliminazione
                          newLogs.push("Nessun altro da eliminare! Eliminazione annullata.");
                          firstVictim = null;
                      }
                  }

                  let finalVictims = [];
                  if (firstVictim) {
                      finalVictims.push(firstVictim);
                      
                      // --- IDOL CHECK (Second Victim - solo in doppia eliminazione) ---
                      if (isDouble && data.eliminatedSecond) {
                          let secondVictim = data.eliminatedSecond;
                          if (secondVictim === firstVictim) { // Se il secondo eliminato è stato promosso a primo
                             // In una doppia eliminazione, l'obiettivo è eliminare i due con più voti. 
                             // Se il primo si salva, il "runner-up" diventa il primo eliminato, e il prossimo più votato (quarto in linea) dovrebbe uscire come secondo.
                             // Per semplicità, consideriamo il secondo elemento di 'eliminated' come il secondo più votato.
                             const topTwoIds = Object.keys(data.voteCounts).sort((a, b) => data.voteCounts[b] - data.voteCounts[a]);
                             
                             // Trova l'ID del concorrente che è al secondo posto in termini di voti, e non è già nella lista dei finalVictims
                             let nextVictim = topTwoIds.find(id => !finalVictims.includes(id) && lobby.players.find(p => p.uid === id).status === 'active');
                             
                             secondVictim = nextVictim;

                          } else if (secondVictim === lobby.idolData?.holder && lobby.idolData?.active) {
                              newLogs.push(`COSA?! ${lobby.players.find(p => p.uid === secondVictim).name} usa il SECONDO Idolo dell'Immunità (non supportato per semplicità, ma il dramma è vero!)`);
                              updates[`idolData.active`] = false; 
                              updates[`idolData.holder`] = null;
                              // Annullo la seconda eliminazione se c'è un idolo in gioco (solo un idolo per ora)
                              secondVictim = null; 
                          }

                          if (secondVictim && secondVictim !== firstVictim) {
                              finalVictims.push(secondVictim);
                          }
                      }
                  }

                  // Esecuzione eliminazioni
                  let updatedPlayers = lobby.players;
                  let rankingEntries = [];
                  
                  finalVictims.forEach(vId => {
                      const victim = updatedPlayers.find(p => p.uid === vId);
                      if (!victim || victim.status !== 'active') return; 

                      updatedPlayers = updatedPlayers.map(p => p.uid === vId ? { ...p, status: 'eliminated' } : p);
                      rankingEntries.push({ 
                          name: victim.name, 
                          team: victim.team || "Merge", 
                          round: lobby.round, 
                          season: currentSeason.name,
                          immunities: victim.immunityWins || 0,
                          votes: victim.totalVotesReceived || 0
                      });
                      newLogs.push(`${victim.name} è stato eliminato!`);
                  });


                  // Fine Logica
                  
                  const nextRound = lobby.round + 1;
                  const redemptionConfig = lobby.config.redemption;
                  let isRedemptionEpisode = false;
                  
                  if (redemptionConfig && redemptionConfig.enabled && redemptionConfig.episodes) {
                      if (Array.isArray(redemptionConfig.episodes)) {
                           isRedemptionEpisode = redemptionConfig.episodes.includes(nextRound);
                      }
                  }

                  if (finalVictims.length > 0) {
                      updates.players = updatedPlayers;
                      updates.rankings = arrayUnion(...rankingEntries);
                  }

                  if (isRedemptionEpisode) {
                      updates = {
                        ...updates,
                        phase: 'redemption',
                        redemptionData: { active: true, stage: 'selection', candidates: [], rolls: {} },
                        round: nextRound,
                        votes: {},
                        immunity: [],
                        diceRoll: null,
                        losingTeam: null,
                        ceremonyData: null,
                        challengeData: null,
                        logs: arrayUnion(...newLogs, `--- EPISODIO SPECIALE: REDEMPTION! ---`)
                      };
                  } else {
                      updates = {
                        ...updates,
                        phase: 'episode_start',
                        round: nextRound,
                        votes: {},
                        immunity: [],
                        diceRoll: null,
                        losingTeam: null,
                        ceremonyData: null,
                        challengeData: null,
                        logs: arrayUnion(...newLogs)
                      };
                  }
                  
              }
            }
            else if (lobby.phase === 'game_over') {
            }

            await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), updates);
          };

          const resolveFinalRound = async () => {
              if (!isHost || lobby.phase !== 'final_showdown') return;
              
              const p1 = activePlayers[0];
              const p2 = activePlayers[1];
              const { currentRolls } = lobby.finalData;
              
              if (!currentRolls || !currentRolls[p1.uid] || !currentRolls[p2.uid]) return; 

              const r1 = currentRolls[p1.uid];
              const r2 = currentRolls[p2.uid];
              
              let fd = { ...lobby.finalData };
              let winner = null;
              let log = "";

              if (r1 > r2) {
                  fd.p1Score += 1;
                  log = `${p1.name} vince il round ${fd.round} (${r1} vs ${r2})`;
              } else if (r2 > r1) {
                  fd.p2Score += 1;
                  log = `${p2.name} vince il round ${fd.round} (${r2} vs ${r1})`;
              } else {
                  log = `Pareggio al round ${fd.round} (${r1} vs ${r1})`;
              }
              
              fd.history.push({ r1, r2, win: r1 > r2 ? p1.name : r2 > r1 ? p2.name : 'Draw' });
              fd.round += 1;
              fd.currentRolls = {}; 

              let updates = { finalData: fd, logs: arrayUnion(log) };

              if (fd.p1Score >= 3 || fd.p2Score >= 3) {
                  winner = fd.p1Score >= 3 ? p1 : p2;
                  
                  const loser = fd.p1Score >= 3 ? p2 : p1;
                  const loserEntry = { 
                      name: loser.name, 
                      team: "FINALIST", 
                      round: "FINALE", 
                      season: currentSeason.name,
                      immunities: loser.immunityWins || 0,
                      votes: loser.totalVotesReceived || 0
                  };
                  
                  if (lobby.currentSeasonIndex < lobby.config.numSeasons - 1) {
                     updates.phase = 'season_setup'; 
                     updates.seasonWinners = arrayUnion(winner.name);
                     updates.logs = arrayUnion(`${winner.name} VINCE LA STAGIONE! Preparazione Stagione Successiva.`);
                     updates.rankings = arrayUnion(loserEntry);
                     
                     const maxReturning = lobby.players.length;
                     const humanCount = lobby.players.filter(p => !p.isBot).length;
                     setNextSeasonConfig({
                        returningCount: Math.min(maxReturning, Math.max(2, humanCount)), 
                        numTeams: lobby.config.numTeams,
                        mergeSize: lobby.config.mergeSize || Math.floor(lobby.config.maxPlayers / 2)
                     });

                  } else {
                     updates.phase = 'game_over';
                     updates.seasonWinners = arrayUnion(winner.name);
                     const winnerEntry = { 
                         name: winner.name, 
                         team: "WINNER", 
                         round: "WINNER", 
                         season: currentSeason.name,
                         immunities: winner.immunityWins || 0,
                         votes: winner.totalVotesReceived || 0 
                     };
                     // FIX: Add both entries to rankings
                     updates.rankings = arrayUnion(loserEntry, winnerEntry); 
                     updates.logs = arrayUnion(`GIOCO FINITO!`);
                  }
              }

              await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), updates);
          };

          const calculateBotVotes = (lobbyState, isMerge) => {
            const votes = {};
            const activeBots = lobbyState.players.filter(p => {
                if (!p.isBot || p.status !== 'active') return false;
                if (isMerge) return true;
                return p.team === lobbyState.losingTeam;
            });

            let candidates = [];
            
            if (isMerge) {
                candidates = lobbyState.players.filter(p => p.status === 'active' && !(lobbyState.immunity || []).includes(p.uid));
            } else {
                candidates = lobbyState.players.filter(p => p.status === 'active' && p.team === lobbyState.losingTeam && !(lobbyState.immunity || []).includes(p.uid));
            }

            activeBots.forEach(bot => {
                let targets = candidates.filter(t => t.uid !== bot.uid);
                if (targets.length === 0) return;

                targets.sort(() => Math.random() - 0.5);

                const targetsWithScore = targets.map(t => ({
                    uid: t.uid,
                    score: bot.relationships[t.uid] || 0
                }));

                const minScore = Math.min(...targetsWithScore.map(t => t.score));

                const potentialVictims = targetsWithScore.filter(t => t.score === minScore);

                const victim = potentialVictims[Math.floor(Math.random() * potentialVictims.length)];
                
                votes[bot.uid] = victim.uid; // Correzione: uso chiave diretta per l'oggetto voti
            });
            return votes;
          };

          const calculateCeremonyResults = (lobbyState, currentVotes, isMerge, isDoubleElimination = false) => {
              const counts = {};
              const activePlayers = lobbyState.players.filter(p => p.status === 'active');
              const validTargetIds = isMerge 
                ? activePlayers.filter(p => !(lobbyState.immunity || []).includes(p.uid)).map(p => p.uid)
                : activePlayers.filter(p => p.team === lobbyState.losingTeam).map(p => p.uid);

              Object.values(currentVotes).forEach(tId => {
                  if (validTargetIds.includes(tId)) {
                      counts[tId] = (counts[tId] || 0) + 1;
                  }
              });

              // Ordina per voti discendenti
              const sortedVictims = Object.keys(counts).sort((a, b) => counts[b] - counts[a]);
              
              if (sortedVictims.length === 0 && validTargetIds.length > 0) {
                  // Voto nullo, eliminazione casuale (fall back)
                  const rnd = validTargetIds[Math.floor(Math.random() * validTargetIds.length)];
                  return { safe: validTargetIds.filter(id => id !== rnd), bottomTwo: [rnd], eliminated: [rnd], voteCounts: counts, tie: null };
              }

              // Verifica i pareggi per il primo posto (o i primi due in caso di doppia)
              const maxVotes = counts[sortedVictims[0]];
              const ties = sortedVictims.filter(id => counts[id] === maxVotes);
              
              if (ties.length > 1) {
                  // Pareggio per il primo posto. Serve spareggio (solo per singola eliminazione)
                  if (!isDoubleElimination || (isDoubleElimination && ties.length > 2)) { 
                     // Se non è doppia O se c'è un pareggio a 3 o più per i posti in eliminazione
                     return { safe: validTargetIds.filter(id => !ties.includes(id)), bottomTwo: ties, eliminated: null, voteCounts: counts, tie: ties };
                  }
              }

              if (isDoubleElimination && sortedVictims.length >= 2) {
                   const elim1 = sortedVictims[0];
                   const elim2 = sortedVictims[1];
                   
                   const bottomTwo = sortedVictims.slice(0, 2);
                   const safe = validTargetIds.filter(id => id !== elim1 && id !== elim2);

                   // Se c'è un pareggio perfetto per il primo e il secondo posto tra 4 persone (es. 10, 10, 5, 5)
                   if(ties.length === 2 && counts[sortedVictims[2]] < ties[0]) {
                      // Pareggio a 2 per il primo posto, prendiamo entrambi
                      return { safe, bottomTwo: ties, eliminated: ties, voteCounts: counts, tie: null };
                   } else {
                       // Elimina i primi due
                       return { safe, bottomTwo, eliminated: [elim1, elim2], voteCounts: counts, tie: null };
                   }
              }

              // Eliminazione singola
              const elimId = sortedVictims[0];
              const bottomTwo = sortedVictims.slice(0, 2);
              if (!bottomTwo.includes(elimId)) bottomTwo.push(elimId); // Assicurati che l'eliminato sia in bottomTwo
              
              let safe = validTargetIds.filter(id => !bottomTwo.includes(id));
              safe.sort((a, b) => (counts[a] || 0) - (counts[b] || 0)); // Ordina i salvi per voti crescenti
              
              return { safe, bottomTwo, eliminated: [elimId], voteCounts: counts, tie: null };
          };

          const handleInteraction = async (type) => {
              const targetId = selectedPlayer?.uid;
              if (!targetId || lobby.phase !== 'social' || hasActed || myPlayer.status === 'eliminated') return;
              
              let msg = "";
              let updatedPlayers = [...lobby.players];
              const targetIdx = updatedPlayers.findIndex(p => p.uid === targetId);
              const targetName = updatedPlayers[targetIdx].name; 
              const actorName = myPlayer.name;
              
              if (type === 'friend') {
                  if (Math.random() > 0.5) {
                      const newVal = Math.min(5, (updatedPlayers[targetIdx].relationships[user.uid] || 0) + 1);
                      updatedPlayers[targetIdx].relationships = { ...updatedPlayers[targetIdx].relationships, [user.uid]: newVal };
                      msg = `Hai stretto amicizia con ${updatedPlayers[targetIdx].name}.`;
                  } else msg = `${updatedPlayers[targetIdx].name} ti ha ignorato.`;
              } 
              else if (type === 'callout') {
                  if (Math.random() > 0.4) {
                     const randomOther = updatedPlayers.find(p => p.isBot && p.uid !== targetId && p.uid !== user.uid);
                     if (randomOther) {
                         const rIdx = updatedPlayers.findIndex(p => p.uid === randomOther.uid);
                         updatedPlayers[rIdx].relationships = { ...updatedPlayers[rIdx].relationships, [targetId]: Math.max(-5, (updatedPlayers[rIdx].relationships[targetId] || 0) - 2) };
                         // Messaggio esplicito di successo
                         msg = `📢 ${targetName}! ${actorName} ha fatto un Call Out contro di te (Riuscito)!`;
                     } else msg = `Call Out di ${actorName}: nessuno ha ascoltato.`;
                  } else { 
                     updatedPlayers[targetIdx].relationships = { ...updatedPlayers[targetIdx].relationships, [user.uid]: Math.max(-5, (updatedPlayers[targetIdx].relationships[user.uid] || 0) - 2) };
                     // Messaggio esplicito di fallimento
                     msg = `📢 ${targetName}! ${actorName} ha provato un Call Out contro di te (Fallito)!`;
                  }
              }
              else if (type === 'alliance') {
                 if ((updatedPlayers[targetIdx].relationships[user.uid] || 0) <= 0) {
                     // Non uso alert() come da istruzioni, ma un console log con fallback UI 
                     // per far capire che l'azione non è andata a buon fine.
                     console.error("Devi essere amico per proporre un'alleanza!");
                     msg = `${updatedPlayers[targetIdx].name} ha rifiutato l'alleanza. (Devi essere amico!)`;
                 }
                 
                 const currentAlliances = Array.isArray(updatedPlayers[targetIdx].alliances) ? updatedPlayers[targetIdx].alliances : [];
                 const myAlliances = Array.isArray(myPlayer.alliances) ? myPlayer.alliances : [];

                 if ((updatedPlayers[targetIdx].relationships[user.uid] || 0) > 0 && Math.random() > 0.5) {
                     const p1Allies = [...currentAlliances, user.uid];
                     const p2Allies = [...myAlliances, targetId];
                     
                     updatedPlayers[targetIdx].alliances = [...new Set(p1Allies)];
                     updatedPlayers.find(p => p.uid === user.uid).alliances = [...new Set(p2Allies)];
                     
                     msg = `Alleanza formata con ${updatedPlayers[targetIdx].name}!`;
                 } else if ((updatedPlayers[targetIdx].relationships[user.uid] || 0) > 0) {
                    msg = `${updatedPlayers[targetIdx].name} ha rifiutato l'alleanza.`;
                 }
              }

              await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
                  players: updatedPlayers,
                  logs: arrayUnion(msg)
              });
              setHasActed(true);
              setSelectedPlayer(null);
          };

          const submitVote = async (targetId) => {
              if (!targetId || lobby.phase !== 'voting') return;
              
              const myTeam = myPlayer.team;
              const losingTeam = lobby.losingTeam;
              if (!isMerge && myTeam !== losingTeam) {
                  console.error("NON PUOI VOTARE! Il tuo team ha vinto l'immunità.");
                  return;
              }

              await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', lobbyId), {
                  [`votes.${user.uid}`]: targetId
              });
          };

          const teams = useMemo(() => {
             const groups = {};
             (lobby.config.numTeams > 0 ? TEAM_NAMES.slice(0, lobby.config.numTeams) : ["MERGE"]).forEach(t => groups[t] = []);
             if (isMerge) groups["MERGE"] = activePlayers;
             else activePlayers.forEach(p => { if (!groups[p.team]) groups[p.team] = []; groups[p.team].push(p); });
             return groups;
          }, [activePlayers, isMerge, lobby.config.numTeams]);

          // --- LOGICA ATTESA VOTI ---
          const pendingVotesCount = useMemo(() => {
              if (lobby.phase !== 'voting') return 0;
              const voters = isMerge 
                  ? activePlayers 
                  : activePlayers.filter(p => p.team === lobby.losingTeam);
              // Correzione: Filtro via i bot dal conteggio pending
              return voters.filter(p => !p.isBot && !lobby.votes?.[p.uid]).length;
          }, [lobby.phase, lobby.votes, isMerge, activePlayers, lobby.losingTeam]);

          // --- LOGICA ATTESA SOCIAL ---
          const pendingReadyCount = useMemo(() => {
              if (lobby.phase !== 'social') return 0;
              const humans = activePlayers.filter(p => !p.isBot);
              const ready = lobby.readyPlayers || [];
              return humans.filter(h => !ready.includes(h.uid)).length;
          }, [lobby.phase, lobby.readyPlayers, activePlayers]);

          return (
            <div className="flex h-screen bg-cover bg-center text-white overflow-hidden font-sans" style={{ backgroundImage: `url('${currentSeason.bg}')` }}>
               <div className="absolute inset-0 bg-black/60 backdrop-blur-sm"></div>
               
               {selectedPlayer && lobby.phase === 'social' && (
                   <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-md p-4">
                       <div className="bg-slate-900 rounded-2xl border-2 border-yellow-500 max-w-sm w-full relative">
                           <button onClick={() => setSelectedPlayer(null)} className="absolute top-2 right-2 bg-black/50 p-2 rounded-full"><X size={20}/></button>
                           <div className="p-6 text-center">
                               <h2 className="text-3xl font-black mb-1">{selectedPlayer.name}</h2>
                               <div className="text-sm text-slate-400 mb-4">{selectedPlayer.team || "Merge"}</div>
                               <div className="grid grid-cols-2 gap-4 mb-6">
                                   <div className="bg-slate-800 p-2 rounded">
                                       <div className="text-xs uppercase">Amicizia</div>
                                       <div className={`text-xl font-bold ${(selectedPlayer.relationships[user.uid] || 0) > 0 ? 'text-green-500' : 'text-red-500'}`}>{selectedPlayer.relationships[user.uid] || 0}</div>
                                   </div>
                                   <div className="bg-slate-800 p-2 rounded">
                                       <div className="text-xs uppercase">Alleato?</div>
                                       <div className="text-xl font-bold">{(Array.isArray(selectedPlayer.alliances) && selectedPlayer.alliances.includes(user.uid)) ? "SÌ" : "NO"}</div>
                                   </div>
                               </div>
                               {!hasActed && myPlayer.status === 'active' && (
                                   <div className="space-y-2">
                                       <button onClick={() => handleInteraction('friend')} className="w-full bg-green-600 py-3 rounded font-bold flex justify-center gap-2"><Heart/> Amicizia</button>
                                       <button onClick={() => handleInteraction('alliance')} className="w-full bg-blue-600 py-3 rounded font-bold flex justify-center gap-2"><Swords/> Alleanza</button>
                                       <button onClick={() => handleInteraction('callout')} className="w-full bg-orange-600 py-3 rounded font-bold flex justify-center gap-2"><AlertTriangle/> Call Out</button>
                                   </div>
                               )}
                           </div>
                       </div>
                   </div>
               )}

               <div className="hidden md:flex relative w-64 bg-slate-900/90 border-r border-slate-700 flex-col z-10">
                  <div className="p-4 border-b border-slate-700">
                     <h2 className="text-lg font-black text-yellow-400 uppercase">{currentSeason.name}</h2>
                     <div className="text-xs font-bold text-slate-400">EPISODIO {Math.ceil(lobby.round)}</div>
                  </div>
                  <div className="flex-1 overflow-y-auto p-2">
                     {lobby.logs.slice().reverse().map((l, i) => {
                         const isMe = l.includes(myPlayer.name);
                         return (
                             <div key={i} className={`mb-1 text-xs border-l-2 pl-2 py-1 ${isMe ? 'border-yellow-500 bg-yellow-500/10 font-bold opacity-100' : 'border-slate-600 opacity-80'}`}>{l}</div>
                         );
                     })}
                  </div>
               </div>

               <div className="flex-1 flex flex-col relative z-0 overflow-hidden">
                  <div className="h-14 bg-slate-800/90 flex items-center justify-between px-4 z-20 border-b border-white/10">
                     <div className="font-bold italic text-white flex items-center gap-2">
                        {lobby.phase === 'idol_hunt' && "CACCIA ALL'IDOLO"}
                        {lobby.phase === 'challenge' && "SFIDA IN CORSO"}
                        {lobby.phase === 'social' && "SOCIALIZZAZIONE"}
                        {lobby.phase === 'voting' && "CABINA ELETTORALE"}
                        {lobby.phase === 'ceremony' && "CERIMONIA"}
                        {lobby.phase === 'final_showdown' && "GRAN FINALE"}
                        {lobby.phase === 'season_setup' && "SETUP STAGIONE"}
                        {lobby.phase === 'redemption' && "REDEMPTION TIME"}
                     </div>
                     
                     <div className="flex items-center gap-4">
                        {lobby.phase === 'social' && myPlayer.status === 'active' && (
                            (lobby.readyPlayers || []).includes(user.uid) ? (
                                <div className="bg-green-600/50 text-green-200 px-4 py-1 rounded font-bold text-sm flex items-center gap-2 border border-green-500">
                                    <CheckCircle size={16}/> HAI FINITO
                                </div>
                            ) : (
                                <button onClick={toggleReady} className="bg-green-600 hover:bg-green-500 text-white font-black px-4 py-1 rounded shadow text-sm flex items-center gap-2 animate-pulse">
                                    <CheckCircle size={16}/> HO FINITO
                                </button>
                            )
                        )}

                        {isHost && lobby.phase !== 'final_showdown' && lobby.phase !== 'season_setup' && lobby.phase !== 'redemption' && (
                            <button 
                                onClick={advanceGame} 
                                disabled={(lobby.phase === 'voting' && pendingVotesCount > 0) || (lobby.phase === 'social' && pendingReadyCount > 0) || (lobby.phase === 'idol_hunt' && lobby.idolData.stage === 'selection')}
                                className={`${((lobby.phase === 'voting' && pendingVotesCount > 0) || (lobby.phase === 'social' && pendingReadyCount > 0) || (lobby.phase === 'idol_hunt' && lobby.idolData.stage === 'selection')) ? 'bg-slate-600 text-slate-400 cursor-not-allowed' : 'bg-yellow-500 hover:bg-yellow-400 text-black'} font-black px-4 py-1 rounded shadow text-sm flex items-center gap-2 transition-all`}
                            >
                            {lobby.phase === 'voting' && pendingVotesCount > 0 
                                ? `ATTESA VOTI (UMANI: ${pendingVotesCount})` 
                                : lobby.phase === 'social' && pendingReadyCount > 0
                                    ? `ATTESA GIOCATORI (${pendingReadyCount})`
                                    : lobby.phase === 'idol_hunt' && lobby.idolData.stage === 'selection'
                                        ? 'TUTTI DEVONO SCEGLIERE'
                                        : lobby.phase === 'ceremony' 
                                            ? (lobby.ceremonyData?.finalReveal && !lobby.ceremonyData?.tieMatch ? 'FINISCI' : lobby.ceremonyData?.tieMatch ? 'SPAREGGIO' : 'RIVELA') 
                                            : 'AVANTI'} 
                            {!(lobby.phase === 'voting' && pendingVotesCount > 0) && !(lobby.phase === 'social' && pendingReadyCount > 0) && !(lobby.phase === 'idol_hunt' && lobby.idolData.stage === 'selection') && <ArrowRight size={16} />}
                            </button>
                        )}
                     </div>
                  </div>

                  <div className="flex-1 overflow-y-auto p-4 relative">
                     
                     {/* --- IDOL HUNT VIEW --- */}
                     {lobby.phase === 'idol_hunt' && lobby.idolData && (
                         <div className="flex flex-col items-center justify-center min-h-[80vh]">
                            <h2 className="text-4xl font-black text-yellow-400 mb-2 uppercase drop-shadow-lg">CACCIA AL TESORO</h2>
                            <p className="text-slate-300 mb-8 max-w-xl text-center">
                                Una di queste casse contiene l'<strong>Idolo dell'Immunità</strong>. Se lo trovi, puoi usarlo per salvarti se vieni eliminato! Scegline una.
                            </p>
                            
                            <div className="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 gap-4">
                                {lobby.idolData.crates.map(c => {
                                    const isMine = c.owner === user.uid;
                                    const isTaken = c.owner !== null;
                                    const isRevealed = lobby.idolData.stage === 'reveal';
                                    const hasIdol = c.id === lobby.idolData.luckyIndex;
                                    const ownerName = isTaken ? lobby.players.find(p => p.uid === c.owner)?.name : "";

                                    return (
                                        <button 
                                            key={c.id} 
                                            onClick={() => claimCrate(c.id)}
                                            disabled={isTaken}
                                            className={`
                                                relative w-20 h-20 sm:w-24 sm:h-24 rounded-xl flex flex-col items-center justify-center border-2 transition-all duration-500
                                                ${isMine 
                                                    ? 'border-yellow-400 bg-yellow-500/20 scale-110 shadow-[0_0_15px_rgba(250,204,21,0.5)]' 
                                                    : isTaken 
                                                        ? 'border-slate-700 bg-slate-800 opacity-60' 
                                                        : 'border-slate-500 bg-slate-700 hover:bg-slate-600 hover:scale-105 cursor-pointer'}
                                            `}
                                        >
                                            {isRevealed && isMine ? (
                                                hasIdol ? (
                                                    <Gem size={40} className="text-purple-400 animate-bounce drop-shadow-lg" />
                                                ) : (
                                                    <Skull size={40} className="text-slate-500" />
                                                )
                                            ) : (
                                                <Package size={32} className={isMine ? 'text-yellow-400' : 'text-slate-400'} />
                                            )}

                                            {isTaken && !isRevealed && (
                                                <div className="absolute inset-0 flex items-center justify-center bg-black/50 rounded-xl">
                                                    <Lock size={16} className="text-slate-400"/>
                                                </div>
                                            )}
                                            
                                            {isRevealed && isMine && (
                                                <div className={`absolute -bottom-6 text-[10px] font-bold ${hasIdol ? 'text-purple-400' : 'text-slate-500'}`}>
                                                    {hasIdol ? "TROVATO!" : "VUOTO"}
                                                </div>
                                            )}
                                            
                                            {isTaken && !isMine && (
                                               <div className="absolute -bottom-4 text-[9px] text-slate-500 truncate w-full text-center px-1">
                                                   {ownerName}
                                               </div>
                                            )}
                                        </button>
                                    )
                                })}
                            </div>

                            {lobby.idolData.stage === 'reveal' && (
                                <div className="mt-8 text-center animate-in slide-in-from-bottom">
                                    <div className="text-2xl font-bold mb-2">Tutte le casse sono state aperte!</div>
                                    <p className="text-slate-400">Controlla la tua cassa. Se hai trovato l'idolo, è tuo segreto.</p>
                                    {isHost && <div className="mt-4 text-yellow-400 animate-pulse">Premi AVANTI per iniziare l'Episodio 1</div>}
                                </div>
                            )}
                         </div>
                     )}

                     {/* --- REDEMPTION VIEW --- */}
                     {lobby.phase === 'redemption' && lobby.redemptionData && (
                         <div className="flex flex-col items-center justify-center min-h-full">
                             <div className="text-center mb-8">
                                 <h1 className="text-5xl font-black text-orange-500 mb-2 uppercase tracking-widest drop-shadow-md">Redemption Island</h1>
                                 <p className="text-slate-300 text-xl">Chi merita una seconda chance?</p>
                             </div>

                             {lobby.redemptionData.stage === 'selection' ? (
                                 <div className="bg-slate-800 p-8 rounded-2xl border-2 border-orange-500 max-w-4xl w-full">
                                     <h3 className="text-2xl font-bold mb-4 flex items-center gap-2">
                                         {isHost ? "Seleziona i Candidati (2-4)" : "L'Host sta scegliendo i candidati..."}
                                     </h3>
                                     
                                     {isHost ? (
                                         <>
                                         <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-4 mb-8">
                                             {lobby.players.filter(p => p.status === 'eliminated').map(p => {
                                                 const isSelected = selectedRedemptionCandidates.includes(p.uid);
                                                 return (
                                                     <button 
                                                         key={p.uid}
                                                         onClick={() => {
                                                             if(isSelected) setSelectedRedemptionCandidates(prev => prev.filter(id => id !== p.uid));
                                                             else if(selectedRedemptionCandidates.length < 4) setSelectedRedemptionCandidates(prev => [...prev, p.uid]);
                                                         }}
                                                         className={`relative rounded-xl overflow-hidden aspect-[3/4] transition-all ${isSelected ? 'ring-4 ring-orange-500 scale-105' : 'opacity-60 hover:opacity-100'}`}
                                                     >
                                                         <img src={p.character.img} className="w-full h-full object-cover"/>
                                                         <div className="absolute bottom-0 w-full bg-black/60 text-xs py-1 truncate">{p.name}</div>
                                                     </button>
                                                 )
                                             })}
                                         </div>
                                         <button 
                                             onClick={startRedemptionSelection}
                                             disabled={selectedRedemptionCandidates.length < 2}
                                             className="w-full bg-orange-600 hover:bg-orange-500 disabled:bg-slate-700 text-white font-black py-4 rounded-xl text-xl shadow-lg transition"
                                         >
                                             INIZIA SFIDA (Selezionati: {selectedRedemptionCandidates.length})
                                         </button>
                                         </>
                                     ) : (
                                         <div className="text-center py-12 text-slate-500 italic">In attesa dell'Host...</div>
                                     )}
                                 </div>
                             ) : (
                                 <div className="flex flex-col items-center w-full max-w-5xl">
                                     <div className="flex flex-wrap gap-8 justify-center mb-12">
                                         {lobby.redemptionData.candidates.map(uid => {
                                             const p = lobby.players.find(x => x.uid === uid);
                                             
                                             // --- SAFETY CHECK AGGIUNTO ---
                                             if (!p) return null; 
                                             const rolls = lobby.redemptionData.rolls || {}; 
                                             const roll = rolls[uid];

                                             return (
                                                 <div key={uid} className="bg-slate-800 p-6 rounded-2xl flex flex-col items-center border-2 border-slate-600 w-48 relative">
                                                     {/* --- FALLBACK IMG --- */}
                                                     {p.character && p.character.img ? (
                                                        <img src={p.character.img} className="w-32 h-32 rounded-full border-4 border-slate-500 object-cover mb-4"/>
                                                     ) : (
                                                        <div className="w-32 h-32 rounded-full bg-slate-700 mb-4 animate-pulse"></div>
                                                     )}
                                                     
                                                     <div className="text-xl font-bold mb-2 text-center leading-tight">{p.name}</div>
                                                     
                                                     {roll ? (
                                                         <div className="text-5xl font-black text-orange-400 bg-black/30 px-4 py-2 rounded-lg animate-in zoom-in">{roll}</div>
                                                     ) : (
                                                         <div className="text-slate-500 italic animate-pulse py-4">Lancio...</div>
                                                     )}

                                                     {/* Tasto per umani */}
                                                     {uid === user.uid && !roll && (
                                                         <button onClick={handleRedemptionRoll} className="absolute -bottom-4 bg-orange-600 px-6 py-2 rounded-full font-bold shadow-lg hover:scale-105 transition">LANCIA</button>
                                                     )}
                                                 </div>
                                             )
                                         })}
                                     </div>

                                     {isHost && (
                                         <button 
                                             onClick={resolveRedemption}
                                             className="bg-green-600 hover:bg-green-500 text-white font-black py-3 px-12 rounded-full text-xl shadow-xl flex items-center gap-2 animate-bounce"
                                         >
                                             <Award size={24}/> RISOLVI SFIDA
                                         </button>
                                     )}
                                 </div>
                             )}
                         </div>
                     )}

                    {lobby.phase === 'season_setup' && isHost && nextSeasonConfig && (
                        <div className="flex flex-col items-center justify-center min-h-[60vh] p-4">
                            <div className="bg-slate-800 p-8 rounded-2xl shadow-2xl border-2 border-yellow-500 max-w-lg w-full">
                                <h2 className="text-3xl font-black text-center mb-6 text-yellow-400">CONFIGURA STAGIONE {lobby.currentSeasonIndex + 2}</h2>
                                <p className="text-slate-400 text-center mb-8">La stagione precedente si è conclusa. Decidi i parametri per la nuova stagione con i concorrenti che ritornano (Max: {lobby.players.length}).</p>

                                <div className="space-y-6">
                                    
                                    <div>
                                        <label className="block text-slate-400 font-bold mb-2 flex justify-between items-center">
                                            Concorrenti di Ritorno
                                        </label>
                                        <div className="flex items-center gap-4">
                                            <input 
                                                type="range" 
                                                min={Math.max(2, lobby.players.filter(p => !p.isBot).length)} 
                                                max={lobby.players.length} 
                                                value={nextSeasonConfig.returningCount} 
                                                onChange={e => setNextSeasonConfig({...nextSeasonConfig, returningCount: parseInt(e.target.value)})} 
                                                className="flex-1 accent-yellow-500" 
                                            />
                                            <span className="text-2xl font-bold w-12 text-center">{nextSeasonConfig.returningCount}</span>
                                        </div>
                                    </div>
                                    
                                    <div>
                                        <label className="block text-slate-400 font-bold mb-2">Nuovo Numero di Squadre (2 - 8)</label>
                                        <div className="flex items-center gap-4">
                                            <input 
                                                type="range" 
                                                min="2" 
                                                max="8" 
                                                value={nextSeasonConfig.numTeams} 
                                                onChange={e => setNextSeasonConfig({...nextSeasonConfig, numTeams: parseInt(e.target.value)})} 
                                                className="flex-1 accent-blue-500" 
                                            />
                                            <span className="text-2xl font-bold w-12 text-center">{nextSeasonConfig.numTeams}</span>
                                        </div>
                                    </div>

                                    <div>
                                        <label className="block text-slate-400 font-bold mb-2 flex justify-between items-center">
                                            Dimensione della Fusione (Merge)
                                            <span className="text-sm text-slate-500">(Max: {nextSeasonConfig.returningCount})</span>
                                        </label>
                                        <div className="flex items-center gap-4">
                                            <input 
                                                type="range" 
                                                min="2" 
                                                max={nextSeasonConfig.returningCount} 
                                                value={nextSeasonConfig.mergeSize} 
                                                onChange={e => setNextSeasonConfig({...nextSeasonConfig, mergeSize: parseInt(e.target.value)})} 
                                                className="flex-1 accent-red-500" 
                                            />
                                            <span className="text-2xl font-bold w-12 text-center">{nextSeasonConfig.mergeSize}</span>
                                        </div>
                                    </div>

                                    <div className="flex justify-center pt-6">
                                        <button 
                                            onClick={() => startNextSeason(nextSeasonConfig)} 
                                            className="bg-green-600 hover:bg-green-500 text-white py-3 px-8 rounded-xl font-black text-xl shadow-lg transition transform hover:scale-105"
                                        >
                                            INIZIA STAGIONE {lobby.currentSeasonIndex + 2}
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                     
                     {lobby.phase === 'challenge' && isMerge && lobby.challengeData && (
                        <div className="flex flex-col items-center justify-center min-h-[60vh]">
                            {lobby.challengeData.stage === 'rolling' ? (
                                <div className="text-center animate-pulse w-full max-w-4xl">
                                    <h2 className="text-3xl font-bold mb-4 uppercase flex items-center justify-center gap-3">
                                        {lobby.challengeData.type === 'sudden_death' && <AlertOctagon size={40} className="text-red-600"/>}
                                        {lobby.challengeData.type === 'sudden_death' && <span className="text-red-500 font-black">ELIMINAZIONE DIRETTA (LOWEST ROLL)</span>}
                                        {lobby.challengeData.type === 'team' && "SFIDA A SQUADRE (50% IMMUNITÀ)"}
                                        {lobby.challengeData.type === 'individual' && "SFIDA INDIVIDUALE"}
                                    </h2>
                                    
                                    <div className="mb-8">
                                        <div className="text-2xl font-bold text-slate-300">Tocca a:</div>
                                        <div className="text-5xl font-black text-yellow-400">
                                            {lobby.players.find(p => p.uid === lobby.challengeData.players[lobby.challengeData.rollingIndex])?.name || "..."}
                                        </div>
                                    </div>
                                    
                                    {lobby.challengeData.players[lobby.challengeData.rollingIndex] === user.uid && (
                                        <button onClick={handleUserRoll} className="bg-gradient-to-r from-purple-600 to-pink-600 text-white font-black text-2xl px-12 py-6 rounded-2xl shadow-xl hover:scale-105 transition animate-bounce mb-8">
                                            <Dices size={32} className="inline mr-2"/> CLICCA PER LANCIARE
                                        </button>
                                    )}

                                    {/* VISUALIZZAZIONE DADI */}
                                    <div className="flex flex-wrap gap-4 justify-center">
                                        {lobby.challengeData.type === 'team' ? (
                                            /* TEAM VIEW */
                                            <div className="flex w-full gap-8 justify-center">
                                                {['A', 'B'].map(team => {
                                                    const teamMembers = Object.entries(lobby.challengeData.teams).filter(([u, t]) => t === team).map(([u]) => u);
                                                    const teamScore = teamMembers.reduce((acc, uid) => acc + (lobby.challengeData.rolls[uid] || 0), 0);
                                                    
                                                    return (
                                                        <div key={team} className={`flex-1 bg-slate-800/50 p-4 rounded-xl border-4 ${team === 'A' ? 'border-red-500' : 'border-blue-500'}`}>
                                                            <div className={`text-2xl font-black mb-4 ${team === 'A' ? 'text-red-400' : 'text-blue-400'}`}>
                                                                {team === 'A' ? "SQUADRA ROSSA" : "SQUADRA BLU"} ({teamScore})
                                                            </div>
                                                            <div className="flex flex-wrap justify-center gap-2">
                                                                {teamMembers.map(uid => {
                                                                    const p = lobby.players.find(pl => pl.uid === uid);
                                                                    const roll = lobby.challengeData.rolls[uid];
                                                                    return (
                                                                        <div key={uid} className="bg-slate-900 p-2 rounded flex items-center gap-2">
                                                                            <img src={p.character.img} className="w-8 h-8 rounded-full"/>
                                                                            <span className="font-bold">{roll || "-"}</span>
                                                                        </div>
                                                                    )
                                                                })}
                                                            </div>
                                                        </div>
                                                    )
                                                })}
                                            </div>
                                        ) : (
                                            /* INDIVIDUAL / SUDDEN DEATH VIEW */
                                            Object.entries(lobby.challengeData.rolls).map(([uid, val]) => {
                                                const p = lobby.players.find(pl => pl.uid === uid);
                                                return (
                                                    <div key={uid} className={`bg-slate-800 p-4 rounded-xl flex flex-col items-center border ${lobby.challengeData.type === 'sudden_death' ? 'border-red-500' : 'border-slate-600'} animate-in zoom-in`}>
                                                        <img src={p.character.img} className="w-12 h-12 rounded-full mb-2"/>
                                                        <div className={`text-3xl font-black ${lobby.challengeData.type === 'sudden_death' ? 'text-red-400' : 'text-white'}`}>{val}</div>
                                                    </div>
                                                )
                                            })
                                        )}
                                    </div>
                                </div>
                            ) : (
                                <div className="text-center animate-in zoom-in duration-500">
                                     <Trophy size={80} className="text-yellow-400 mx-auto mb-4"/>
                                     <h1 className="text-5xl font-black text-white mb-2">IMMUNITÀ</h1>
                                     <div className="text-2xl text-yellow-400 font-bold mb-8 flex flex-wrap justify-center gap-2">
                                         {lobby.immunity.map(uid => (
                                             <div key={uid} className="bg-yellow-500/20 px-4 py-2 rounded-lg border border-yellow-500">
                                                 {lobby.players.find(p => p.uid === uid)?.name}
                                             </div>
                                         ))}
                                     </div>
                                     {isHost && <div className="text-sm text-slate-400">Clicca Avanti per continuare</div>}
                                </div>
                            )}
                        </div>
                     )}

                     {lobby.phase === 'voting' && (
                         <div className="flex flex-col items-center">
                             <h2 className="text-3xl font-black mb-2 flex items-center gap-2"><Vote /> CHI VUOI ELIMINARE?</h2>
                             
                             {!isMerge && myPlayer.team !== lobby.losingTeam ? (
                                 <div className="mt-8 bg-green-600/20 border-2 border-green-500 p-8 rounded-2xl text-center animate-in zoom-in">
                                     <Coffee size={48} className="mx-auto mb-4 text-green-400" />
                                     <h3 className="text-2xl font-black text-green-400 mb-2">SEI SALVO!</h3>
                                     <p className="text-slate-300">Il tuo team ha vinto l'immunità. Rilassati e guarda il team <span className="font-bold text-red-400">{lobby.losingTeam}</span> scannarsi.</p>
                                 </div>
                             ) : (
                                <>
                                 <p className="mb-8 text-slate-400">Clicca sul concorrente per votarlo. Il voto è segreto.</p>
                                 
                                 {myPlayer.status === 'eliminated' ? (
                                     <div className="text-xl text-red-500 font-bold">SEI STATO ELIMINATO, NON PUOI VOTARE.</div>
                                 ) : (
                                     <div className="grid grid-cols-4 md:grid-cols-6 gap-4">
                                         {activePlayers.map(p => {
                                             const canVoteFor = (!isMerge && p.team === lobby.losingTeam) || (isMerge && !(lobby.immunity || []).includes(p.uid));
                                             if (!canVoteFor || p.uid === user.uid) return null;
                                             
                                             const iVotedFor = lobby.votes?.[user.uid] === p.uid;

                                             return (
                                                 <button 
                                                    key={p.uid} 
                                                    onClick={() => submitVote(p.uid)}
                                                    className={`relative group rounded-xl overflow-hidden aspect-[3/4] transition-all ${iVotedFor ? 'ring-4 ring-red-600 scale-105' : 'hover:scale-105 opacity-80 hover:opacity-100'}`}
                                                 >
                                                     <img src={p.character.img} className="w-full h-full object-cover"/>
                                                     <div className="absolute inset-0 bg-black/40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity font-black text-red-500 text-xl tracking-widest bg-black/60">
                                                         VOTA
                                                     </div>
                                                     {iVotedFor && <div className="absolute inset-0 flex items-center justify-center bg-red-600/50 font-black text-white">VOTATO</div>}
                                                 </button>
                                             )
                                         })}
                                     </div>
                                 )}
                                 <div className="mt-8 text-slate-500 italic">Attendi che l'host chiuda le votazioni...</div>
                               </>
                             )}
                         </div>
                     )}

                     {lobby.phase === 'final_showdown' && lobby.finalData && (
                         <div className="flex flex-col items-center h-full">
                             <h1 className="text-4xl font-black text-yellow-400 mb-8 uppercase tracking-widest">GRAN FINALE</h1>
                             
                             <div className="flex items-center justify-center gap-12 w-full max-w-4xl mb-12">
                                 <div className="text-center">
                                     <img src={activePlayers[0].character.img} className="w-32 h-32 rounded-full border-4 border-blue-500 object-cover mb-4"/>
                                     <h2 className="text-2xl font-bold">{activePlayers[0].name}</h2>
                                     
                                     {lobby.finalData.currentRolls?.[activePlayers[0].uid] ? (
                                         <div className="text-4xl font-black text-white bg-blue-600 p-4 rounded-xl mt-4 animate-in zoom-in">
                                             {lobby.finalData.currentRolls[activePlayers[0].uid]}
                                         </div>
                                     ) : (
                                         <div className="text-slate-500 mt-4 italic animate-pulse">Lancio in corso...</div>
                                     )}

                                     <div className="text-6xl font-black mt-2 text-blue-400">{lobby.finalData.p1Score}</div>
                                 </div>
                                 
                                 <div className="text-4xl font-black text-slate-600">VS</div>

                                 <div className="text-center">
                                     <img src={activePlayers[1].character.img} className="w-32 h-32 rounded-full border-4 border-red-500 object-cover mb-4"/>
                                     <h2 className="text-2xl font-bold">{activePlayers[1].name}</h2>
                                     
                                     {lobby.finalData.currentRolls?.[activePlayers[1].uid] ? (
                                         <div className="text-4xl font-black text-white bg-red-600 p-4 rounded-xl mt-4 animate-in zoom-in">
                                             {lobby.finalData.currentRolls[activePlayers[1].uid]}
                                         </div>
                                     ) : (
                                         <div className="text-slate-500 mt-4 italic animate-pulse">Lancio in corso...</div>
                                     )}

                                     <div className="text-6xl font-black mt-2 text-red-400">{lobby.finalData.p2Score}</div>
                                 </div>
                             </div>

                             {activePlayers.find(p => p.uid === user.uid) && !lobby.finalData.currentRolls?.[user.uid] && (
                                 <button onClick={handleFinalRoll} className="bg-gradient-to-r from-yellow-500 to-orange-500 text-black font-black text-2xl py-4 px-12 rounded-full shadow-lg hover:scale-105 transition flex items-center gap-4 animate-bounce">
                                     <Dices size={32}/> LANCIA IL TUO DADO
                                 </button>
                             )}
                             
                             {isHost && 
                              lobby.finalData.currentRolls && 
                              Object.keys(lobby.finalData.currentRolls).length >= 2 && (
                                 <button onClick={resolveFinalRound} className="bg-green-600 text-white font-black text-xl py-3 px-8 rounded-full shadow-lg hover:scale-105 transition flex items-center gap-2 mt-8 animate-pulse">
                                     <Award size={24}/> ASSEGNA PUNTO
                                 </button>
                             )}

                             <div className="mt-4 text-slate-400">Vince chi arriva prima a 3 vittorie!</div>
                         </div>
                     )}

                     {lobby.phase === 'game_over' && (
                         <div className="flex flex-col items-center h-full justify-center">
                             <h1 className="text-5xl font-black text-yellow-400 mb-8">CLASSIFICA FINALE</h1>
                             
                             <div className="flex flex-col md:flex-row gap-8 w-full max-w-5xl h-[70vh]">
                                 {/* CLASSIFICA PIAZZAMENTI */}
                                 <div className="flex-1 bg-slate-800 rounded-xl overflow-hidden shadow-2xl border border-slate-700 flex flex-col">
                                     <div className="bg-slate-700/50 p-4 border-b border-slate-600 text-center font-bold text-yellow-400 uppercase tracking-widest sticky top-0">
                                         Piazzamenti
                                     </div>
                                     <div className="flex-1 overflow-y-auto no-scrollbar">
                                         {lobby.rankings.slice().reverse().map((r, i) => {
                                             const charImg = ROSTER.find(c => c.name === r.name)?.img || "";
                                             return (
                                                 <div key={i} className={`flex items-center justify-between p-4 border-b border-slate-700 ${i === 0 ? 'bg-gradient-to-r from-yellow-500/20 to-transparent' : 'hover:bg-slate-700/50'}`}>
                                                     <div className="flex items-center gap-4">
                                                         <div className={`font-black text-xl w-8 text-center flex-shrink-0 ${i === 0 ? 'text-yellow-400 scale-125' : 'text-slate-500'}`}>
                                                            {i === 0 ? <Crown size={24} className="mx-auto"/> : i+1}
                                                         </div>
                                                         
                                                         <div className="w-12 h-12 rounded-full overflow-hidden border-2 border-slate-600 flex-shrink-0">
                                                            {charImg && <img src={charImg} className="w-full h-full object-cover"/>}
                                                         </div>

                                                         <div>
                                                             <div className={`font-bold text-lg ${i === 0 ? 'text-yellow-100' : 'text-white'}`}>{r.name}</div>
                                                             <div className="text-xs text-slate-400 uppercase flex items-center gap-2">
                                                                <span>{r.season} • {r.team}</span>
                                                             </div>
                                                         </div>
                                                     </div>
                                                 </div>
                                             )
                                         })}
                                     </div>
                                 </div>

                                 {/* CLASSIFICA VOTI RICEVUTI (EXTRA) */}
                                 <div className="flex-1 bg-slate-800 rounded-xl overflow-hidden shadow-2xl border border-slate-700 flex flex-col">
                                     <div className="bg-slate-700/50 p-4 border-b border-slate-600 text-center font-bold text-red-400 uppercase tracking-widest sticky top-0 flex items-center justify-center gap-2">
                                         <Target size={20}/> Classifica Bersagli (Voti)
                                     </div>
                                     <div className="flex-1 overflow-y-auto no-scrollbar">
                                         {(() => {
                                            // Sort unique players by votes descending
                                            // Note: lobby.rankings contains everyone eliminated + winner. 
                                            // We use it as source to ensure we have static data, but we sort by 'votes' field.
                                            // Handle potential duplicate names if multi-season but rankings accumulates them.
                                            // For simplicity, we just list them.
                                            const sortedByVotes = [...lobby.rankings].sort((a, b) => (b.votes || 0) - (a.votes || 0));
                                            
                                            return sortedByVotes.map((r, i) => {
                                                const charImg = ROSTER.find(c => c.name === r.name)?.img || "";
                                                return (
                                                 <div key={i} className="flex items-center justify-between p-4 border-b border-slate-700 hover:bg-slate-700/50">
                                                     <div className="flex items-center gap-4">
                                                         <div className="font-bold text-slate-500 w-6 text-center">{i+1}</div>
                                                         <div className="w-10 h-10 rounded-full overflow-hidden border border-slate-600 flex-shrink-0 grayscale opacity-80">
                                                            {charImg && <img src={charImg} className="w-full h-full object-cover"/>}
                                                         </div>
                                                         <div className="font-bold text-white text-sm">{r.name}</div>
                                                     </div>
                                                     <div className="flex items-center gap-2">
                                                         <div className="font-black text-xl text-red-500">{r.votes || 0}</div>
                                                         <span className="text-xs text-slate-500 uppercase">Voti</span>
                                                     </div>
                                                 </div>
                                                );
                                            });
                                         })()}
                                     </div>
                                 </div>
                             </div>
                             
                             <div className="mt-4 text-slate-500 text-sm animate-bounce">
                                <ChevronDown size={24} className="mx-auto"/>
                             </div>
                         </div>
                     )}

                     {(lobby.phase === 'social' || lobby.phase === 'ceremony') && (
                         <>
                         {lobby.phase === 'social' && !isMerge && lobby.losingTeam && (
                            <div className="bg-red-600/90 text-white p-4 rounded-xl mb-4 text-center font-black text-xl shadow-lg border-2 border-red-400 animate-pulse">
                               IL TEAM {lobby.losingTeam.toUpperCase()} HA PERSO! <br/>
                            </div>
                         )}

                         {lobby.phase === 'ceremony' && lobby.ceremonyData ? (
                            <div className="flex flex-col items-center justify-center min-h-[50vh]">
                                {lobby.ceremonyData.tieMatch ? (
                                     <div className="text-center">
                                         <h2 className="text-3xl font-black text-red-500 mb-4 animate-bounce">PAREGGIO!</h2>
                                         <p className="mb-6">Spareggio dadi: Chi fa il numero più basso ESCE.</p>
                                         
                                         {(lobby.ceremonyData.tieMatch.candidates || []).includes(user.uid) && !lobby.ceremonyData.tieMatch.rolls[user.uid] && (
                                             <button onClick={handleTieBreakRoll} className="bg-red-600 text-white px-8 py-4 rounded-xl font-black text-xl mb-8 animate-pulse shadow-xl">
                                                 LANCIA DADO SALVEZZA
                                             </button>
                                         )}

                                         <div className="flex gap-8 justify-center">
                                             {lobby.ceremonyData.tieMatch.candidates.map(uid => {
                                                 const p = lobby.players.find(pl => pl.uid === uid);
                                                 const roll = lobby.ceremonyData.tieMatch.rolls[uid];
                                                 return (
                                                     <div key={uid} className="bg-slate-800 p-6 rounded-xl flex flex-col items-center border-2 border-slate-600">
                                                         <img src={p.character.img} className="w-24 h-24 rounded-full mb-4 border-4 border-slate-500"/>
                                                         <div className="text-xl font-bold mb-2">{p.name}</div>
                                                         {roll ? (
                                                             <div className="text-4xl font-black text-yellow-400">{roll}</div>
                                                         ) : (
                                                             <div className="text-slate-500 italic animate-pulse">Sta lanciando...</div>
                                                         )}
                                                     </div>
                                                 )
                                             })}
                                         </div>
                                     </div>
                                ) : (
                                    <>
                                    <Flame size={64} className="text-orange-500 animate-pulse mb-4" />
                                    {lobby.ceremonyData.isDoubleElimination && <div className="text-3xl font-black text-red-500 mb-2">DOPPIA ELIMINAZIONE!</div>}
                                    {lobby.ceremonyData.isOpenVote && <div className="text-xl font-black text-red-400 mb-2 bg-black/40 px-4 rounded animate-pulse">VOTI PALESI</div>}
                                    <h2 className="text-3xl font-black text-white mb-6">IL FUOCO DECIDE</h2>
                                    
                                    <div className="flex flex-wrap justify-center gap-2 mb-8 max-w-3xl">
                                        {lobby.ceremonyData.safe.slice(0, lobby.ceremonyData.revealedCount).map(uid => {
                                            const p = lobby.players.find(pl => pl.uid === uid);
                                            const votes = lobby.ceremonyData.voteCounts?.[uid] || 0;
                                            return (
                                                <div key={uid} className="bg-green-600/20 border border-green-500 p-2 rounded flex flex-col items-center min-w-[80px] animate-in fade-in zoom-in">
                                                    <div className="flex items-center gap-2 mb-1">
                                                        <img src={p.character.img} className="w-8 h-8 rounded-full object-cover"/>
                                                        <span className="font-bold text-sm">{p.name}</span>
                                                    </div>
                                                    <div className="text-xs bg-black/40 px-2 rounded-full text-slate-300">
                                                        {votes} voti
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                    
                                    {lobby.ceremonyData.revealedCount >= lobby.ceremonyData.safe.length && (
                                        <div className="flex gap-8 items-center mt-4">
                                            {lobby.ceremonyData.bottomTwo.map(uid => {
                                                const p = lobby.players.find(pl => pl.uid === uid);
                                                const isEliminated = lobby.ceremonyData.finalReveal && ((Array.isArray(lobby.ceremonyData.eliminated) && lobby.ceremonyData.eliminated.includes(uid)) || (uid === lobby.ceremonyData.eliminated));
                                                const isSafe = lobby.ceremonyData.finalReveal && !isEliminated;
                                                const votes = lobby.ceremonyData.voteCounts?.[uid] || 0;
                                                const showVotes = isEliminated || (isSafe && lobby.ceremonyData.finalReveal);

                                                return (
                                                    <div key={uid} className={`flex flex-col items-center transition-all duration-1000 ${isEliminated ? 'opacity-50 grayscale scale-90' : isSafe ? 'scale-110 ring-4 ring-green-500 rounded-xl' : ''}`}>
                                                        <img src={p.character.img} className="w-32 h-32 object-cover rounded-xl border-4 border-white shadow-2xl"/>
                                                        <div className="font-black text-xl mt-2 bg-black/50 px-2 rounded">{p.name}</div>
                                                        <div className="font-mono text-yellow-400 font-bold mt-1 text-lg">
                                                            {showVotes ? `${votes} voti` : "?"}
                                                        </div>
                                                        {/* VISUALIZZAZIONE NOMI VOTANTI */}
                                                        {showVotes && lobby.ceremonyData.isOpenVote && lobby.ceremonyData.votersMap?.[uid] && (
                                                            <div className="text-[10px] text-slate-300 max-w-[120px] text-center mt-1 bg-black/50 p-1 rounded animate-in zoom-in">
                                                                <span className="text-red-400 font-bold">Votato da:</span><br/>
                                                                {lobby.ceremonyData.votersMap[uid].join(", ")}
                                                            </div>
                                                        )}
                                                        {isEliminated && <div className="text-red-500 font-black text-2xl mt-2 rotate-12 border-4 border-red-500 px-4 rounded-xl bg-black">ELIMINATO</div>}
                                                    </div>
                                                )
                                            })}
                                        </div>
                                    )}
                                    </>
                                )}
                            </div>
                         ) : (
                            <div className="space-y-8">
                               {Object.entries(teams).map(([teamName, players]) => (
                                   players.length > 0 && (
                                   <div key={teamName} className="bg-slate-800/50 p-4 rounded-xl border border-white/5">
                                       <h3 className={`font-black text-lg mb-3 px-2 border-l-4 ${teamName === lobby.losingTeam ? 'border-red-500 text-red-400' : 'border-green-500 text-green-400'}`}>
                                           {teamName} ({players.length})
                                       </h3>
                                       <div className="grid grid-cols-4 sm:grid-cols-5 md:grid-cols-6 lg:grid-cols-8 gap-2">
                                           {players.map(p => {
                                               const isMe = p.uid === user.uid;
                                               const isImmune = (lobby.immunity || []).includes(p.uid);
                                               const rel = p.relationships[user.uid] || 0;
                                               const isAlly = Array.isArray(p.alliances) && p.alliances.includes(user.uid);
                                               const isReady = (lobby.readyPlayers || []).includes(p.uid);

                                               return (
                                                   <div 
                                                     key={p.uid} 
                                                     onClick={() => !isMe && setSelectedPlayer(p)}
                                                     className={`relative group bg-slate-800 rounded overflow-hidden shadow-lg transition-all cursor-pointer hover:scale-105 hover:ring-2 hover:ring-white ${isMe ? 'ring-2 ring-yellow-400 cursor-default hover:scale-100' : ''}`}
                                                   >
                                                       <div className="aspect-[3/4] relative">
                                                           <img src={p.character.img} className="w-full h-full object-cover" />
                                                           <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-transparent to-transparent"></div>
                                                           {isImmune && <Shield size={16} className="absolute top-1 right-1 text-yellow-400 fill-yellow-400 drop-shadow-md" />}
                                                           
                                                           {/* INDICATORE PRONTO */}
                                                           {lobby.phase === 'social' && !p.isBot && isReady && (
                                                               <div className="absolute top-1 left-1 bg-green-500 rounded-full p-0.5" title="Pronto">
                                                                    <CheckCircle size={14} className="text-white"/>
                                                               </div>
                                                           )}

                                                           {!isMe && (
                                                               <div className="absolute top-1 left-1 flex flex-col gap-1">
                                                                   {rel !== 0 && (
                                                                       <div className={`text-[10px] font-black px-1 rounded flex items-center gap-0.5 ${rel > 0 ? 'bg-green-600' : 'bg-red-600'}`}>
                                                                           <Heart size={8} fill="currentColor"/> {rel}
                                                                       </div>
                                                                   )}
                                                                   {isAlly && (
                                                                       <div className="text-[10px] font-black bg-blue-600 px-1 rounded flex items-center gap-0.5">
                                                                           <Swords size={8} />
                                                                       </div>
                                                                   )}
                                                               </div>
                                                           )}
                                                           <div className="absolute bottom-0 w-full p-1 text-center">
                                                               <div className="font-bold text-white text-xs truncate leading-tight">{p.name}</div>
                                                           </div>
                                                       </div>
                                                   </div>
                                               )
                                           })}
                                       </div>
                                   </div>
                                   )
                               ))}
                            </div>
                         )}
                         </>
                     )}
                  </div>
               </div>

               <div className="w-64 bg-slate-900 border-l border-slate-700 flex flex-col z-20">
                  <div className="p-3 border-b border-slate-700 font-bold text-xs uppercase text-slate-400 flex items-center gap-2">
                     <MessageSquare size={14} /> Chat Gruppo
                  </div>
                  <div className="flex-1 overflow-y-auto p-2 space-y-2" ref={chatRef}>
                     {lobby.chat?.map((msg, i) => (
                         <div key={i} className="text-xs">
                             <span className={`font-bold ${msg.sender === myPlayer.name ? 'text-yellow-400' : 'text-blue-400'}`}>{msg.sender}:</span>
                             <span className="text-slate-300 ml-1 break-words">{msg.text}</span>
                         </div>
                     ))}
                  </div>
                  <form onSubmit={sendChat} className="p-2 border-t border-slate-700 flex gap-2">
                     <input 
                       value={chatInput}
                       onChange={e => setChatInput(e.target.value)}
                       placeholder="Scrivi..."
                       className="flex-1 bg-slate-800 rounded px-2 py-1 text-xs text-white outline-none focus:ring-1 focus:ring-yellow-500"
                     />
                     <button type="submit" className="bg-yellow-500 text-black p-1 rounded hover:bg-yellow-400">
                        <Send size={14} />
                     </button>
                  </form>
               </div>
            </div>
          );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>